---
layout: post
title:  "Docker 开始，第2部分：容器 "
date:   2017-02-14
excerpt: "Get Started, Part 2: Containers"
tags: [Docker]
comments: true
---
> Prerequisites 
> - Install Docker version 1.13 or higher . 
> - Read the orientation in Part 1 . 
> - Give your environment a quick test run to make sure you’re all set up: 
> ```
> docker run hello-world 
> ```

 前提
 - 安装Docker 1.13版本或更高。
 - 阅读第1部分的目标。
 - 给您的环境一个快速的测试运行，以确保您已经做好了准备：
 ```
 docker run hello-world 
 ```
 
> Introduction 
 
 介绍 
 
> It’s time to begin building an app the Docker way. We start at the bottom of the hierarchy of such an app, which is a container, which we cover on this page. Above this level is a service, which defines how containers behave in production, covered in Part 3 . Finally, at the top level is the stack, defining the interactions of all the services, covered in Part 5 .  
> - Stack 
> - Services 
> - Container

 是时候开始用Docker的方式来构建一个应用程序了。我们从这样一个应用程序的层次结构的底部开始，这个应用程序是一个容器，我们在这个页面中介绍了这个容器。在此级别之上的是一个服务，它定义了容器在生产中的行为方式，第3部分介绍了这一点。最后，在顶层是堆栈，定义了第5部分中讨论的所有服务的交互。 
 - 堆栈
 - 服务
 - 容器
 
 Your new development environment 
 
 您的新开发环境 
 
 In the past, if you were to start writing a Python app, your first order of business was to install a Python runtime onto your machine. But, that creates a situation where the environment on your machine needs to be perfect for your app to run as expected, and also needs to match your production environment. 
 
 在过去，如果您开始编写Python应用程序，您的第一个业务是在您的机器上安装Python运行时。但是，这会创建一个环境，您的机器上的环境需要完美地按照预期运行，而且还需要与生产环境相匹配。<br/> 
 
 With Docker, you can just grab a portable Python runtime as an image, no installation necessary. Then, your build can include the base Python image right alongside your app code, ensuring that your app, its dependencies, and the runtime, all travel together. 
 
 使用Docker，您只需获取一个可移植的Python运行时作为映像，无需安装。然后，您的构建可以将基本Python映像与应用程序代码放在一起，确保应用程序、其依赖项和运行时都能一起运行。 
 
 These portable images are defined by something called a Dockerfile . 
 
 这些可移植映像是由一个叫做Dockerfile的东西定义的。 
 
 Define a container with Dockerfile 
 
 用Dockerfile定义容器 
 
 Dockerfile defines what goes on in the environment inside your container. Access to resources like networking interfaces and disk drives is virtualized inside this environment, which is isolated from the rest of your system, so you need to map ports to the outside world, and be specific about what files you want to “copy in” to that environment. However, after doing that, you can expect that the build of your app defined in this Dockerfile behaves exactly the same wherever it runs. 
 
 Dockerfile定义了容器内环境中发生的事情。在这个环境中，对网络接口和磁盘驱动器等资源的访问是虚拟化的，这与系统的其他部分是隔离的，因此您需要将端口映射到外部世界，并具体说明要将哪些文件“复制”到该环境。但是，在这样做之后，您可以预期在这个Dockerfile中定义的应用程序的构建在运行的任何地方都是完全相同的。 
 
 Dockerfile 
 
 Dockerfile 
 
 Create an empty directory. Change directories ( cd ) into the new directory, create a file called Dockerfile , copy-and-paste the following content into that file, and save it. Take note of the comments that explain each statement in your new Dockerfile. 
 
 创建一个空目录。将目录(Cd)更改为新目录，创建一个名为Dockerfile的文件，将以下内容复制并粘贴到该文件中，并保存它。注意解释新Dockerfile中每条语句的注释。 
 
 # Use an official Python runtime as a parent image FROM python:2.7-slim # Set the working directory to /app WORKDIR /app # Copy the current directory contents into the container at /app ADD . /app # Install any needed packages specified in requirements.txt RUN pip install --trusted-host pypi.python.org -r requirements.txt # Make port 80 available to the world outside this container EXPOSE 80 # Define environment variable ENV NAME World # Run app.py when the container launches CMD ["python", "app.py"] 
 
 #使用Python官方运行时作为python的父映像：2.7-SIM#将工作目录设置为/app WORKDIR/app#，将当前目录内容复制到容器中，在/app Add./app#安装在requments.txt中指定的任何所需软件包，运行pipinstall-可信-主机pypi.python.org-r Requiments.txt#使端口80在此容器外公开80#定义环境变量env name World。#当容器启动CMD[“python”，“app.py”]时运行app.py 
 
 Are you behind a proxy server? Proxy servers can block connections to your web app once it’s up and running. If you are behind a proxy server, add the following lines to your Dockerfile, using the ENV command to specify the host and port for your proxy servers: # Set proxy server, replace host:port with values for your servers ENV http_proxy host : port ENV https_proxy host : port Add these lines before the call to pip so that the installation succeeds. 
 
 你在代理服务器后面吗？代理服务器一旦启动并运行，就可以阻止连接到Web应用程序。如果你是一个代理服务器之后，添加以下代码到你的dockerfile，使用env命令来指定您的代理服务器主机和端口：#设置代理服务器，取代主持人：与您的服务器环境http_proxy主机值端口：端口：端口的主机环境https_proxy添加这些行之前调用PIP所以安装成功。<br/> 
 
 This Dockerfile refers to a couple of files we haven’t created yet, namely app.py and requirements.txt . Let’s create those next. 
 
 这个Dockerfile引用了一些我们尚未创建的文件，即app.py和requments.txt。让我们创建下一个。 
 
 The app itself 
 
 应用程序本身 
 
 Create two more files, requirements.txt and app.py , and put them in the same folder with the Dockerfile . This completes our app, which as you can see is quite simple. When the above Dockerfile is built into an image, app.py and requirements.txt is present because of that Dockerfile ’s ADD command, and the output from app.py is accessible over HTTP thanks to the EXPOSE command. 
 
 再创建两个文件，即requments.txt和app.py，并将它们与Dockerfile放在同一个文件夹中。这就完成了我们的应用程序，正如您所看到的，这是相当简单的。当将上述Dockerfile内置到映像中时，app.py和requments.txt就会出现，因为Dockerfile的Add命令是存在的，而app.py的输出可以通过HTTP访问，这要归功于公开命令。 
 
 requirements.txt 
 
 requirements.txt<br/> 
 
 Flask Redis 
 
 瓶红 
 
 app.py 
 
 app.py<br/> 
 
 from flask import Flask from redis import Redis , RedisError import os import socket # Connect to Redis redis = Redis ( host = "redis" , db = 0 , socket_connect_timeout = 2 , socket_timeout = 2 ) app = Flask ( __name__ ) @app.route ( "/" ) def hello (): try : visits = redis . incr ( "counter" ) except RedisError : visits = "<i>cannot connect to Redis, counter disabled</i>" html = "<h3>Hello {name}!</h3>" \ "<b>Hostname:</b> {hostname}<br/>" \ "<b>Visits:</b> {visits}" return html . format ( name = os . getenv ( "NAME" , "world" ), hostname = socket . gethostname (), visits = visits ) if __name__ == "__main__" : app . run ( host = '0.0.0.0' , port = 80 ) 
 
 从烧瓶导入从Redis导入Redis，RedisError导入os导入套接字#Connect到Redis redis=Redis(host=“redis”，db=0，Socket_CONNECT_TIMOUT=2，app=Flask(__Name__)@app.path(“/”)def hello()：try：access=redis.incr(“计数器”)，除了RedisError：vises=<i>不能连接到Redis，禁用的计数器</i>“html=”<h3>Hello{name}！</h3>“\b>Hostname：</b>{hostname}<br/>”<b>访问：</b>{access}“html”返回.格式(name=os.getenv(“name”)，)，主机名=Socket.gethostname()，访问=访问)if__name__==“__main___”：app.run(host=‘0.0.0.0’，port=80) 
 
 Now we see that pip install -r requirements.txt installs the Flask and Redis libraries for Python, and the app prints the environment variable NAME , as well as the output of a call to socket.gethostname() . Finally, because Redis isn’t running (as we’ve only installed the Python library, and not Redis itself), we should expect that the attempt to use it here fails and produces the error message. 
 
 现在我们看到pipinstall-r requments.txt为Python安装了Flask和Redis库，应用程序输出环境变量名以及对socket.gethostname()的调用输出。最后，由于Redis没有运行(因为我们只安装了Python库，而没有安装Redis本身)，所以我们应该期望在这里使用它的尝试会失败并产生错误消息。 
 
 Note : Accessing the name of the host when inside a container retrieves the container ID, which is like the process ID for a running executable. 
 
 注意：在容器中检索容器ID时访问主机名，这就像运行中的可执行文件的进程ID一样。 
 
 That’s it! You don’t need Python or anything in requirements.txt on your system, nor does building or running this image install them on your system. It doesn’t seem like you’ve really set up an environment with Python and Flask, but you have. 
 
 是这么回事！你不需要requirements.txt Python或什么对你的系统，也没有建立或运行该图像安装在你的系统。看起来你并不是真的用Python和水瓶建立了一个环境，但是你有。<br/> 
 
 Build the app 
 
 构建应用程序 
 
 We are ready to build the app. Make sure you are still at the top level of your new directory. Here’s what ls should show: 
 
 我们已经准备好构建这个应用程序了。确保您仍然处于新目录的顶层。下面是ls应该展示的内容： 
 
 $ ls Dockerfile		app.py			requirements.txt 
 
 $ls Dockerfile app.py需求 
 
 Now run the build command. This creates a Docker image, which we’re going to tag using -t so it has a friendly name. 
 
 现在运行Build命令。这将创建一个Docker映像，我们将使用-t标记它，这样它就有了一个友好的名称。 
 
 docker build -t friendlyhello . 
 
 码头工人建立了-不友好的你好。 
 
 Where is your built image? It’s in your machine’s local Docker image registry: 
 
 你的形象在哪里？它在您机器的本地Docker映像注册表中： 
 
 $ docker image ls REPOSITORY            TAG                 IMAGE ID friendlyhello         latest              326387cea398 
 
 泊坞窗图像LS仓库美元标签图像ID friendlyhello新326387cea398<br/> 
 
 Run the app 
 
 运行应用程序 
 
 Run the app, mapping your machine’s port 4000 to the container’s published port 80 using -p : 
 
 运行应用程序，使用-p将机器的端口4000映射到容器的发布端口80： 
 
 docker run -p 4000:80 friendlyhello 
 
 码头客跑-p 4000：80友好你好 
 
 You should see a message that Python is serving your app at http://0.0.0.0:80 . But that message is coming from inside the container, which doesn’t know you mapped port 80 of that container to 4000, making the correct URL http://localhost:4000 . 
 
 您应该可以在http：//0.0.0.0：80上看到Python正在为您的应用程序服务的消息。但是该消息来自容器内部，它不知道您将容器的端口80映射到4000，从而生成正确的URL http：//localhost：4000。 
 
 Go to that URL in a web browser to see the display content served up on a web page. 
 
 转到Web浏览器中的URL，查看在网页上提供的显示内容。<br/> 
 
 Note : If you are using Docker Toolbox on Windows 7, use the Docker Machine IP instead of localhost . For example, http://192.168.99.100:4000/. To find the IP address, use the command docker-machine ip . 
 
 注意：如果在Windows 7上使用Docker工具箱，请使用DockerMachineIP而不是localhost。例如，http：//192.168.99.100：4000/。若要查找IP地址，请使用命令停靠机IP。 
 
 You can also use the curl command in a shell to view the same content. 
 
 还可以在shell中使用curl命令查看相同的内容。 
 
 $ curl http://localhost:4000  <h3>Hello World!</h3><b>Hostname:</b> 8fc990912a14<br/><b>Visits:</b> <i>cannot connect to Redis, counter disabled</i> 
 
 $curl http：//localhost：4000<h3>Hello World！</h3><b>主机名称：</b>8fc990912a14<br/><b>访问：</b><i>不能连接到Redis，计数器禁用</i> 
 
 This port remapping of 4000:80 is to demonstrate the difference between what you EXPOSE within the Dockerfile , and what you publish using docker run -p . In later steps, we just map port 80 on the host to port 80 in the container and use http://localhost . 
 
 这个4000：80的端口重映射是为了演示您在Dockerfile中公开的内容与使用dockerrun-p发布的文件之间的区别。在后面的步骤中，我们只需将主机上的端口80映射到容器中的端口80，并使用http：//localhost。 
 
 Hit CTRL+C in your terminal to quit. 
 
 在你的终端点击CTRL C退出。 
 
 On Windows, explicitly stop the container On Windows systems, CTRL+C does not stop the container. So, first  type CTRL+C to get the prompt back (or open another shell), then type docker container ls to list the running containers, followed by docker container stop <Container NAME or ID> to stop the  container. Otherwise, you get an error response from the daemon  when you try to re-run the container in the next step. 
 
 在Windows上，在Windows系统上显式停止容器，CTRLC不停止容器。因此，首先键入CTRLC以获得提示(或打开另一个shell)，然后键入docker容器ls列出正在运行的容器，然后键入docker容器停止<Containername或ID>以停止容器。否则，在下一步尝试重新运行容器时，将从守护进程获得错误响应。 
 
 Now let’s run the app in the background, in detached mode: 
 
 现在让我们在后台以分离模式运行该应用程序： 
 
 docker run -d -p 4000:80 friendlyhello 
 
 码头客跑-d-p 4000：80友好你好 
 
 You get the long container ID for your app and then are kicked back to your terminal. Your container is running in the background. You can also see the abbreviated container ID with docker container ls (and both work interchangeably when running commands): 
 
 你得到你的应用程序的长容器ID，然后被踢回你的终端。您的容器正在后台运行。您还可以看到带有docker容器ls的缩写容器ID(在运行命令时两者都可以互换工作)： 
 
 $ docker container ls CONTAINER ID        IMAGE               COMMAND             CREATED 1fa4ab2cf395        friendlyhello "python app.py" 28 seconds ago 
 
 $docker容器ls容器ID映像命令在28秒钟前创建了1fa4ab2cf395 
 
 Notice that CONTAINER ID matches what’s on http://localhost:4000 . 
 
 注意，容器ID与http：//localhost：4000上的内容匹配。 
 
 Now use docker container stop to end the process, using the CONTAINER ID , like so: 
 
 现在使用docker容器停止来结束进程，使用容器ID，如下所示： 
 
 docker container stop 1fa4ab2cf395 
 
 码头货柜站1fa4ab2cf 395 
 
 Share your image 
 
 分享你的形象 
 
 To demonstrate the portability of what we just created, let’s upload our built image and run it somewhere else. After all, you need to know how to push to registries when you want to deploy containers to production. 
 
 为了演示我们刚刚创建的图像的可移植性，让我们上传构建的映像并在其他地方运行它。毕竟，当您想要将容器部署到生产中时，您需要知道如何推送到注册中心。 
 
 A registry is a collection of repositories, and a repository is a collection of images—sort of like a GitHub repository, except the code is already built. An account on a registry can create many repositories. The docker CLI uses Docker’s public registry by default. 
 
 注册表是存储库的集合，存储库是图像的集合--有点像GitHub存储库，只是代码已经构建。注册中心上的帐户可以创建许多存储库。默认情况下，码头CLI使用Docker的公共注册表。 
 
 Note : We use Docker’s public registry here just because it’s free and pre-configured, but there are many public ones to choose from, and you can even set up your own private registry using Docker Trusted Registry . 
 
 注意：我们在这里使用Docker的公共注册表仅仅是因为它是免费的和预先配置的，但是有许多公共注册表可供选择，您甚至可以使用Docker受信任的注册表来设置您自己的私有注册表。 
 
 Log in with your Docker ID 
 
 用您的码头ID登录 
 
 If you don’t have a Docker account, sign up for one at cloud.docker.com . Make note of your username. 
 
 如果你没有Docker账户，可以在Cloud.docker.com注册一个账户。记下你的用户名。 
 
 Log in to the Docker public registry on your local machine. 
 
 登录到本地计算机上的Docker公共注册表。 
 
 $ docker login 
 
 $Docker登录<br/> 
 
 Tag the image 
 
 Tag the image 
 
 The notation for associating a local image with a repository on a registry is username/repository:tag . The tag is optional, but recommended, since it is the mechanism that registries use to give Docker images a version. Give the repository and tag meaningful names for the context, such as get-started:part2 . This puts the image in the get-started repository and tag it as part2 . 
 
 将本地映像与注册表上的存储库相关联的符号是username/reposer：tag。标记是可选的，但建议使用它，因为它是注册表用来为Docker图像提供一个版本的机制。为上下文提供存储库和标记有意义的名称，如Get-start：Part 2。这会将映像放到Get-start存储库中，并将其标记为第2部分。 
 
 Now, put it all together to tag the image. Run docker tag image with your username, repository, and tag names so that the image uploads to your desired destination. The syntax of the command is: 
 
 现在，把它放在一起标记图像。运行带有用户名、存储库和标记名的docker标记映像，以便图像上载到所需的目标。该命令的语法是： 
 
 docker tag image username/repository:tag 
 
 Docker标记图像用户名/存储库：标记 
 
 For example: 
 
 例如： 
 
 docker tag friendlyhello john/get-started:part2 
 
 Docker标签友好你好John/入门：第2部分 
 
 Run docker image ls to see your newly tagged image. (You can also use docker image ls .) 
 
 运行停靠图像ls以查看新标记的图像。(您还可以使用码头映像ls。) 
 
 $ docker image ls REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE friendlyhello            latest              d9e555c53008        3 minutes ago       195MB john/get-started         part2               d9e555c53008        3 minutes ago       195MB python                   2.7-slim            1c7128a655f6        5 days ago          183MB ... 
 
 $docker映像ls存储库标记映像ID创建了大小--- 
 
 Publish the image 
 
 Publish the image 
 
 Upload your tagged image to the repository: 
 
 将标记的图像上载到存储库： 
 
 docker push username/repository:tag 
 
 Docker推送用户名/存储库：标记 
 
 Once complete, the results of this upload are publicly available. If you log in to Docker Hub , you see the new image there, with its pull command. 
 
 一旦完成，这个上传的结果是公开的。如果您登录到Docker Hub，您将在那里看到新的图像，并使用它的拉命令。 
 
 Pull and run the image from the remote repository 
 
 从远程存储库中拉和运行映像<br/> 
 
 From now on, you can use docker run and run your app on any machine with this command: 
 
 从现在开始，您可以使用docker运行并在任何机器上运行应用程序，并使用以下命令： 
 
 docker run -p 4000:80 username/repository:tag 
 
 Docker Run-p 4000：80用户名/存储库：标记 
 
 If the image isn’t available locally on the machine, Docker pulls it from the repository. 
 
 如果映像在机器上本地不可用，Docker将从存储库中提取图像。 
 
 $ docker run -p 4000:80 john/get-started:part2 Unable to find image 'john/get-started:part2' locally part2: Pulling from john/get-started 10a267c67f42: Already exists f68a39a6a5e4: Already exists 9beaffc0cf19: Already exists 3c1fe835fb6b: Already exists 4c9f1fa8fcb8: Already exists ee7d8f576a14: Already exists fbccdcced46e: Already exists Digest: sha256:0601c866aab2adcc6498200efd0f754037e909e5fd42069adeff72d1e2439068 Status: Downloaded newer image for john/get-started:part2 * Running on http://0.0.0.0:80/ ( Press CTRL+C to quit ) 
 
 ... 
 
 No matter where docker run executes, it pulls your image, along with Python and all the dependencies from requirements.txt , and runs your code. It all travels together in a neat little package, and you don’t need to install anything on the host machine for Docker to run it. 
 
 无论在何处执行docker运行，它都会提取映像以及Python和来自requments.txt的所有依赖项，并运行代码。所有这些都是在一个整洁的小包中一起运行的，您不需要在主机上安装任何东西就可以运行Docker。 
 
 Conclusion of part two 
 
 第二部分结论 
 
 That’s all for this page. In the next section, we learn how to scale our application by running this container in a service . 
 
 这一页就这么多了。在下一节中，我们将学习如何通过在服务中运行这个容器来扩展应用程序。 
 
 Continue to Part 3 » 
 
 继续第3部分 
 
 Recap and cheat sheet (optional) 
 
 重述和备忘单(可选) 
 
 Here’s a terminal recording of what was covered on this page : 
 
 以下是本页所涵盖内容的终端记录： 
 
 Here is a list of the basic Docker commands from this page, and some related ones if you’d like to explore a bit before moving on. 
 
 下面列出了这个页面中的基本Docker命令，以及一些相关的命令，如果您想在继续之前进行一番探索的话。 
 
 docker build -t friendlyhello . # Create image using this directory's Dockerfile docker run -p 4000:80 friendlyhello # Run "friendlyname" mapping port 4000 to 80 docker run -d -p 4000:80 friendlyhello # Same thing, but in detached mode docker container ls # List all running containers docker container ls -a # List all containers, even those not running docker container stop < hash > # Gracefully stop the specified container docker container kill < hash > # Force shutdown of the specified container docker container rm < hash > # Remove specified container from this machine docker container rm $( docker container ls -a -q ) # Remove all containers docker image ls -a # List all images on this machine docker image rm <image id> # Remove specified image from this machine docker image rm $( docker image ls -a -q ) # Remove all images from this machine docker login # Log in this CLI session using your Docker credentials docker tag <image> username/repository:tag # Tag <image> for upload to registry docker push username/repository:tag # Upload tagged image to registry docker run username/repository:tag # Run image from a registry 
 
 码头工人建立T friendlyhello。#创建图像使用这个目录的dockerfile Docker运行P 4000:80 friendlyhello #运行“友好名称”映射端口4000至80码头运行D P 4000:80 friendlyhello #相同的事，但在独立模式LS #列出所有运行Docker容器容器Docker容器LS - #列出所有的容器，即使是那些没有运行Docker容器< > #停止哈希优雅地停止指定的集装箱码头工人容器杀死<哈希> #强制关闭指定的集装箱码头工人容器RM <哈希> #从本机Docker容器删除指定容器$（Docker容器LS—Q）#删除所有集装箱码头工人形象是一#列表中的所有图片在这机的码头工人形象RM <图像标识> #从本机码头删除指定的图像二图像人民币（泊坞窗图像LS—Q）#删除所有图像从本机登录登录使用您# Docker Docker凭据Docker标签<图像>用户名/库在CLI会话：标签#标签<图像>上传注册表泊坞窗推用户名/库：标签#上传标记图像注册表搬运工跑用户名/库：从注册表标签#运行图像<br/> 
 
 containers , python , code , coding , build , push , run 
 
 容器，python，代码，编码，生成，推送，运行 
 
 PDRTJS_settings_8453675 = { 										"id": "8453675", 										"unique_id": "get-started/part2.md", 										"title": "Get Started, Part 2: Containers", 										"permalink": "https://github.com/docker/docker.github.io/blob/master/get-started/part2.md" 									}; 									(function(d, c, j) { 										if (!document.getElementById(j)) { 											var pd = d.createElement(c), 												s; 											pd.id = j; 											pd.src = ('https:' == document.location.protocol) ? 'https://polldaddy.com/js/rating/rating.js' : 'http://i0.poll.fm/js/rating/rating.js'; 											s = document.getElementsByTagName(c)[0]; 											s.parentNode.insertBefore(pd, s); 										} 									}(document, 'script', 'pd-rating-js')); 
 
 ... 
 
 
 
 

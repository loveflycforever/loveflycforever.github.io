---
layout: post
title:  "Jersey 章节 5. 客户端 API"
subtitle: "Chapter 5. Client API"
tags: [Jersey]
comments: true
---
章节 5. 客户端 API

> Chapter 5. Client API

本节介绍 JAX-RS 客户端 API，这是一个基于 Java 的为了和 RESTful Web 服务流畅通信的API 。这个标准的 API 它也是 Java EE 7 的一部分，目的是使它很容易的在 HTTP 协议下使用 Web 服务，使开发人员能够简洁高效地利用现有的技术实现可移植客户端解决方案和建立客户端的 HTTP 连接的实现。

> This section introduces the JAX-RS Client API, which is a fluent Java based API for communication with RESTful Web services. This standard API that is also part of Java EE 7 is designed to make it very easy to consume a Web service exposed via HTTP protocol and enables developers to concisely and efficiently implement portable client-side solutions that leverage existing and well established client-side HTTP connector implementations.

JAX-RS 客户端 API 可以用来使用任何 HTTP 协议上的 Web 服务或它的扩展（例如 WebDAV ），并不仅限于使用JAX-RS实现的服务。然而，熟悉 JAX-RS 的开发者们应该找客户端 API 补足他们的服务，尤其是如果客户端 API 是被那些服务自身利用，或测试那些服务。JAX-RS 客户端 API 受到Jersey 1.x 客户端 API 的启发，和熟悉的 Jersey 1.x 的开发者们应该很容易理解所有新 JAX-RS 客户端 API 引入的概念。

> The JAX-RS client API can be utilized to consume any Web service exposed on top of a HTTP protocol or it's extension (e.g. WebDAV), and is not restricted to services implemented using JAX-RS. Yet, developers familiar with JAX-RS should find the client API complementary to their services, especially if the client API is utilized by those services themselves, or to test those services. The JAX-RS client API finds inspiration in the proprietary Jersey 1.x Client API and developers familiar with the Jersey 1.x Client API should find it easy to understand all the concepts introduced in the new JAX-RS Client API.

客户端 API 的目标有三部分：
1. 封装REST架构风格的关键因素，即统一接口的约束和相关的数据元素，作为客户端的 Java artifacts；
2. 使它容易使用暴露在HTTP 下的 RESTful Web 服务，让开发 JAX-RS 服务器端 API 和RESTful Web服务一样简单；
3. 服务器和客户端编程模型之间共享概念和JAX-RS API 延展点。

> The goals of the client API are threefold:
> 1. Encapsulate a key constraint of the REST architectural style, namely the Uniform Interface Constraint and associated data elements, as client-side Java artifacts;
> 2. Make it as easy to consume RESTful Web services exposed over HTTP, same as the JAX-RS server-side API makes it easy to develop RESTful Web services; and
> 3. Share common concepts and extensibility points of the JAX-RS API between the server and the client side programming models.

作为一个标准 JAX-RS 客户端 API 的扩展，Jersey 客户端 API 支持插件式体系结构让不同的底层实现 HTTP 客户端连接器去使用。目前有这样几个由 Jersey 提供的实现。我们有一个默认的客户端连接器使用 HTTP（S）URLConnection 提供 JDK 以及基于Apache的HTTP客户端，Jetty HTTP客户端和 Grizzly 的异步客户端的连接器实现。

> As an extension to the standard JAX-RS Client API, the Jersey Client API supports a pluggable architecture to enable the use of different underlying HTTP client Connector implementations. Several such implementations are currently provided with Jersey. We have a default client connector using Http(s)URLConnection supplied with the JDK as well as connector implementations based on Apache HTTP Client, Jetty HTTP client and Grizzly Asynchronous Client.

5.1. 统一接口约束

> 5.1. Uniform Interface Constraint

统一接口约束限制了RESTful Web 服务的体系结构，以便客户机，如浏览器，能够利用同样的接口去和任何服务进行通信。这是一个在软件工程非常强大的概念，使基于Web的搜索引擎和服务混搭变得可能。它诱导诸如：
1. 简单的结构更容易理解和维护；和
2. 可进化性、松散耦合、客户和服务可以随着时间的推移，也许在新的和意想不到的方式发展，同时保持向后兼容性。

> The uniform interface constraint bounds the architecture of RESTful Web services so that a client, such as a browser, can utilize the same interface to communicate with any service. This is a very powerful concept in software engineering that makes Web-based search engines and service mash-ups possible. It induces properties such as:
> 1. simplicity, the architecture is easier to understand and maintain; and
> 2. evolvability or loose coupling, clients and services can evolve over time perhaps in new and unexpected ways, while retaining backwards compatibility.

需要进一步的限制：
1. 每个资源都由URI标识；
2. 客户端使用一组固定的HTTP方法和通过 HTTP 请求和响应的资源进行交互；
3. 可以返回一个或多个表示，并由媒体类型标识；以及
4. 其中的内容可以链接到更多的资源。

> Further constraints are required:
> 1. every resource is identified by a URI;
> 2. a client interacts with the resource via HTTP requests and responses using a fixed set of HTTP methods;
> 3. one or more representations can be returned and are identified by media types; and
> 4. the contents of which can link to further resources.

上述过程一次又一次地重复操作对于那些曾使用浏览器填写HTML表单并跟随链接的人来说很熟悉。同样的流程也适用于基于非浏览器的客户机。

> The above process repeated over and again should be familiar to anyone who has used a browser to fill in HTML forms and follow links. That same process is applicable to non-browser based clients.

许多现有的基于Java的客户端API，如Apache HTTP client API 或 HttpUrlConnection 提供的JDK过分关注于客户端-服务器约束请求和响应的交流的而不是一种资源，由URI标识，和一套固定的HTTP方法的用法。

> Many existing Java-based client APIs, such as the Apache HTTP client API or HttpUrlConnection supplied with the JDK place too much focus on the Client-Server constraint for the exchanges of request and responses rather than a resource, identified by a URI, and the use of a fixed set of HTTP methods.

在JAX-RS客户端资源的API是Java类 WebTarget 实例。封装一个URI。HTTP方法固定设置可以调用基于WebTarget。表示是java类型，它的实例，可能包含的链接，webtarget新实例可以产生。

> A resource in the JAX-RS client API is an instance of the Java class WebTarget. and encapsulates an URI. The fixed set of HTTP methods can be invoked based on the WebTarget. The representations are Java types, instances of which, may contain links that new instances of WebTarget may be created from.

5.2. JAX-RS artifacts的简易用法和重用

> 5.2. Ease of use and reusing JAX-RS artifacts

自从一个JAX-RS组件被表示为一个带注释的java类型，这使得它易于与其他客户端API进行配置、传递和注入方式是不那么直观的或有可能的。Jersey客户端API复用JAX-RS的许多方面与Jersey实现如：
1. 使用UriTemplate 和 UriBuilder 安全建设构建URI的URI；
2. 内置Java类型支持，如byte[]，String，Number，Boolean，Character，InputStream，java.io.Reader，File，DataSource，JAXB beans以及其他Jersey特有的JSON和多方支持。
3. 使用流畅的构建风格API模式可以更容易地构造请求。

> Since a JAX-RS component is represented as an annotated Java type, it makes it easy to configure, pass around and inject in ways that are not so intuitive or possible with other client-side APIs. The Jersey Client API reuses many aspects of the JAX-RS and the Jersey implementation such as:
> 1. URI building using UriBuilder and UriTemplate to safely build URIs;
> 2. Built-in support for Java types of representations such as byte[], String, Number, Boolean, Character, InputStream, java.io.Reader, File, DataSource, JAXB beans as well as additional Jersey-specific JSON and Multi Part support.
> 3. Using the fluent builder-style API pattern to make it easier to construct requests.

有一些API，如Apache HTTP客户端或者HttpURLConnection是很困难的使用并且/或者需要太多的代码做比较简单的东西，特别是当客户需要了解不同的有效载荷的陈述。这就是为什么实现了JAX-RS客户端API的 Jersey提供了用于包装HttpUrlConnection和Apache HTTP client。因此，它是可能得到JAX-RS实现和特点建立的好处，而得到使用JAX-RS客户端 API 的简单的设计的好处的方便。例如，一个低级别的HTTP客户端库，发送一个带有一堆HTML表单参数的POST请求和接收响应反序列化为 JAXB bean一点都不直截了当。随着新的Jersey支持的JAX-RS客户端API，这个任务是很容易的：
例 5.1. 带有表单参数的 POST 请求
```
Client client = ClientBuilder.newClient();
WebTarget target = client.target("http://localhost:9998").path("resource");
Form form = new Form();
form.param("x", "foo");
form.param("y", "bar");
MyJAXBBean bean =target.request(MediaType.APPLICATION_JSON_TYPE).post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED_TYPE),MyJAXBBean.class);
```

> Some APIs, like the Apache HTTP Client or HttpURLConnection can be rather hard to use and/or require too much code to do something relatively simple, especially when the client needs to understand different payload representations. This is why the Jersey implementation of JAX-RS Client API provides support for wrapping HttpUrlConnection and the Apache HTTP client. Thus it is possible to get the benefits of the established JAX-RS implementations and features while getting the ease of use benefit of the simple design of the JAX-RS client API. For example, with a low-level HTTP client library, sending a POST request with a bunch of typed HTML form parameters and receiving a response de-serialized into a JAXB bean is not straightforward at all. With the new JAX-RS Client API supported by Jersey this task is very easy:
Example 5.1. POST request with form parameters
> ```
> Client client = ClientBuilder.newClient();
> WebTarget target = client.target("http://localhost:9998").path("resource");
> Form form = new Form();
> form.param("x", "foo");
> form.param("y", "bar");
> MyJAXBBean bean =target.request(MediaType.APPLICATION_JSON_TYPE).post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED_TYPE),MyJAXBBean.class);
> ```

在例5.1. 带有表单参数的 POST 请求中，一个新 WebTarget 实例首先创建了一个新的客户端实例，下一个表单实例由两个表单参数创建。一旦准备好，这个表单实例就会被POST方式发送到目标资源。首先，在request（…）方法中指定可接受的媒体类型。然后在post（…）方法，调用基于JAX-RS实体静态方法是构建请求实体实例并附上适当的内容媒体类型去给表单实体被发送。在post（…）方法中的第二个参数指定应该从一个成功的response方法返回的 response 实体的Java类型。在这种情况下，JAXB bean实例要求成功的返回。Jersey客户端API照顾的表单实例序列化，选择合适的MessageBodyWriter<T>，调用 POST 请求和响应消息产生并有效载荷一个JAXB bean 使用适当的MessageBodyReader<T>的实例 。

> In the Example 5.1, “POST request with form parameters” a new WebTarget instance is created using a new Client instance first, next a Form instance is created with two form parameters. Once ready, the Form instance is POSTed to the target resource. First, the acceptable media type is specified in the request(...) method. Then in the post(...) method, a call to a static method on JAX-RS Entity is made to construct the request entity instance and attach the proper content media type to the form entity that is being sent. The second parameter in the post(...) method specifies the Java type of the response entity that should be returned from the method in case of a successful response. In this case an instance of JAXB bean is requested to be returned on success. The Jersey client API takes care of selecting the proper MessageBodyWriter<T> for the serialization of the Form instance, invoking the POST request and producing and de-serialization of the response message payload into an instance of a JAXB bean using a proper MessageBodyReader<T>.

如果上面的代码必须使用HttpUrlConnection，开发者必须编写自定义代码去序列化被发送的 POST 请求内表单数据和反序列化响应输入流到一个JAXB bean 内。此外，更多的代码不得不用于编写使它更加易于重用逻辑和相同资源， 在我们的例子JAX-RS WebTarget实例就是 “http://localhost:8080/resource”。

> If the code above had to be written using HttpUrlConnection, the developer would have to write custom code to serialize the form data that are sent within the POST request and de-serialize the response input stream into a JAXB bean. Additionally, more code would have to be written to make it easy to reuse the logic when communicating with the same resource “http://localhost:8080/resource” that is represented by the JAX-RS WebTarget instance in our example.

5.3. 客户端API概述

> 5.3. Overview of the Client API

5.3.1.  开始使用客户端API

> 5.3.1. Getting started with the client API

参照依赖对当使用Jersey JAX-RS客户端支持依赖细节。

> Refer to the dependencies for details on the dependencies when using the Jersey JAX-RS Client support.

你还可能想使用自定义连接器实现。在这种情况下，你需要在包含你想要使用的自定义客户端连接器的模块上包含额外的依赖项。有关如何使用和配置自定义Jersey客户机传输连接器，请参见“配置自定义连接器”章节。

> You may also want to use a custom Connector implementation. In such case you would need to include additional dependencies on the module(s) containing the custom client connector that you want to use. See section "Configuring custom Connectors" about how to use and configure a custom Jersey client transport Connector.

5.3.2.  创建和配置客户端实例

> 5.3.2.  Creating and configuring a Client instance

JAX-RS客户端API是一个旨在让流利的编程模型。这意味着，一个 Client 实例的构造，从一个WebTarget 创建，并请求调用被建立和调用可以被链接在一个单一的调用的“流”。该流程的各个步骤将在下面的章节中所示。利用客户端API，首先要建立一个 Client， 使用静态ClientBuilder 工厂方法的之一。下面是最简单的例子：
```
Client client = ClientBuilder.newClient();
```

> JAX-RS Client API is a designed to allow fluent programming model. This means, a construction of a Client instance, from which a WebTarget is created, from which a request Invocation is built and invoked can be chained in a single "flow" of invocations. The individual steps of the flow will be shown in the following sections. To utilize the client API it is first necessary to build an instance of a Client using one of the static ClientBuilder factory methods. Here's the most simple example:
> ```
> Client client = ClientBuilder.newClient();
> ```

ClientBuilder是一个用于创建新Client实例的JAX-RS API。在更高级的场景中，如果需要的话，ClientBuilder可以被用于配置额外的客户端实例属性，如SSL传输设置（见下文的 ???）。

> The ClientBuilder is a JAX-RS API used to create new instances of Client. In a slightly more advanced scenarios, ClientBuilder can be used to configure additional client instance properties, such as a SSL transport settings, if needed (see ??? below).

一个 Client 实例可以在通过将ClientConfig传递给newClient（可配置的）ClientBuilder工厂方法创建过程中被配置。ClientConfig实现了Configurable，因此它提供了一些方法来注册提供者（例如，特性或单独的实体提供者，过滤器或拦截器)和设置属性。以下代码显示了自定义客户端过滤器的注册:
```
ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);
```

> A Client instance can be configured during creation by passing a ClientConfig to the newClient(Configurable) ClientBuilder factory method. ClientConfig implements Configurable and therefore it offers methods to register providers (e.g. features or individual entity providers, filters or interceptors) and setup properties. The following code shows a registration of custom client filters:
> ```
> ClientConfig clientConfig = new ClientConfig();
> clientConfig.register(MyClientResponseFilter.class);
> clientConfig.register(new AnotherClientFilter());
> Client client = ClientBuilder.newClient(clientConfig);
> ```
在本例中，过滤器是使用ClientConfig.register(...)方法注册的。有多个支持特性和提供者类或实例的注册方法的重载版本。一旦配置了ClientConfig实例，就可以将它传递给ClientBuilder，以创建预先配置的Client实例。

In the example, filters are registered using the ClientConfig.register(...) method. There are multiple overloaded versions of the method that support registration of feature and provider classes or instances. Once a ClientConfig instance is configured, it can be passed to the ClientBuilder to create a pre-configured Client instance.

注意，Jersey ClientConfig支持Configurable的流式 API 模型，如下所示，配置一个新的客户端实例的代码也可以使用一个更紧凑的样式编写出来。
Client client = ClientBuilder.newClient(new ClientConfig() .register(MyClientResponseFilter.class) .register(new AnotherClientFilter());

Note that the Jersey ClientConfig supports the fluent API model of Configurable. With that the code that configures a new client instance can be also written using a more compact style as shown below.
Client client = ClientBuilder.newClient(new ClientConfig() .register(MyClientResponseFilter.class) .register(new AnotherClientFilter());

利用这种紧凑模式的能力是所有 JAX-RS 和Jersey Client API  组件固有的。

The ability to leverage this compact pattern is inherent to all JAX-RS and Jersey Client API components.

由于Client 也实现了Configurable 接口，因此即使在创建后也可以进一步配置它。重要的是，在Client实例上完成的任何配置更改都不会影响在实例创建时期曾提供初始的Client实例配置的ClientConfig实例。下一段代码展现了现有的客户端实例的配置。
client.register(ThirdClientFilter.class);

Since Client implements Configurable interface too, it can be configured further even after it has been created. Important is to mention that any configuration change done on a Client instance will not influence the ClientConfig instance that was used to provide the initial Client instance configuration at the instance creation time. The next piece of code shows a configuration of an existing Client instance.
client.register(ThirdClientFilter.class);

类似于前面的例子，因为Client.register(...) 方法支持流式API风格，多个客户端实例配置调用可以被链接:
client.register(FilterA.class) .register(new FilterB()) .property("my-property", true);

Similarly to earlier examples, since Client.register(...) method supports the fluent API style, multiple client instance configuration calls can be chained:
client.register(FilterA.class) .register(new FilterB()) .property("my-property", true);

为了获得Client 实例的当前配置，可以使用getConfiguration()方法。
ClientConfig clientConfig = new ClientConfig();clientConfig.register(MyClientResponseFilter.class);clientConfig.register(new AnotherClientFilter());Client client = ClientBuilder.newClient(clientConfig);client.register(ThirdClientFilter.class);Configuration newConfiguration = client.getConfiguration();

To get the current configuration of the Client instance a getConfiguration() method can be used.
ClientConfig clientConfig = new ClientConfig();clientConfig.register(MyClientResponseFilter.class);clientConfig.register(new AnotherClientFilter());Client client = ClientBuilder.newClient(clientConfig);client.register(ThirdClientFilter.class);Configuration newConfiguration = client.getConfiguration();

在代码中，在clientConfig中注册了一个额外的MyClientResponseFilter类和AnotherClientFilter实例。然后使用clientConfig构建一个新的Client 实例。ThirdClientFilter 被单独添加到已经构建好的Client 实例中。这并不影响原来的clientConfig所表示的配置。在最后一步中，newConfiguration被从client重新取回 。这个配置包含所有三个注册过滤器，而原始clientConfig实例仍然只包含两个过滤器。不同于单独创建的clientConfig，从client 实例重新取回的newConfiguration表示一个实时客户端配置视图。对client 实例进行的任何其他配置更改也反映在newConfiguration中。因此，newConfiguration实际上是客户机配置的视图，而不是配置状态副本。这些原则在client API中很重要，并将应用在接下来的章节中。例如，你可以为所有客户机构造一个通用的基本配置(在我们的示例中，它是clientConfig)，然后重用这个公共配置实例可以进一步专门化去配置的多个客户端实例。类似地，你可以使用现有client 实例配置来配置另一个client实例，而不必担心原来的client 实例中的任何副作用。

In the code, an additional MyClientResponseFilter class and AnotherClientFilter instance are registered in the clientConfig. The clientConfig is then used to construct a new Client instance. The ThirdClientFilter is added separately to the constructed Client instance. This does not influence the configuration represented by the original clientConfig. In the last step a newConfiguration is retrieved from the client. This configuration contains all three registered filters while the original clientConfig instance still contains only two filters. Unlike clientConfig created separately, the newConfiguration retrieved from the client instance represents a live client configuration view. Any additional configuration changes made to the client instance are also reflected in the newConfiguration. So, newConfiguration is really a view of the client configuration and not a configuration state copy. These principles are important in the client API and will be used in the following sections too. For example, you can construct a common base configuration for all clients (in our case it would be clientConfig) and then reuse this common configuration instance to configure multiple client instances that can be further specialized. Similarly, you can use an existing client instance configuration to configure another client instance without having to worry about any side effects in the original client instance.

5.3.3. 针对网络资源

5.3.3. Targeting a web resource

一旦你有了一个客户端实例，你就可以根据它创建一个WebTarget。
WebTarget webTarget = client.target("http://example.com/rest");

Once you have a Client instance you can create a WebTarget from it.
WebTarget webTarget = client.target("http://example.com/rest");

客户端包含一些允许创建WebTarget实例的目标target(...)方法。在本例中，我们使用 target(String uri) 版本。作为String传递给方法的uri是目标web资源的URI。在更复杂的场景中，它可能是整个RESTful应用程序的上下文根URI，它可以从表示单个资源目标的WebTarget实例派生和单独配置。这是可能的，因为JAX-RS WebTarget 也实现了Configurable:
WebTarget webTarget = client.target("http://example.com/rest");webTarget.register(FilterForExampleCom.class);

A Client contains several target(...) methods that allow for creation of WebTarget instance. In this case we're using target(String uri) version. The uri passed to the method as a String is the URI of the targeted web resource. In more complex scenarios it could be the context root URI of the whole RESTful application, from which WebTarget instances representing individual resource targets can be derived and individually configured. This is possible, because JAX-RS WebTarget also implements Configurable:
WebTarget webTarget = client.target("http://example.com/rest");webTarget.register(FilterForExampleCom.class);

JAX-RS client API中使用的配置原则也适用于WebTarget。每个WebTarget实例都继承了它的父类(一个client 或其他web target中的一个)的配置，并且可以在不影响父组件的配置的情况下进一步自定义配置。在这种情况下，FilterForExampleCom只能在webTarget中注册，而不能在client。因此，client 仍然可以被用于创建新的WebTarget实例，使用普通客户机配置指向其他uri，而FilterForExampleCom过滤器不是其中的一部分。

The configuration principles used in JAX-RS client API apply to WebTarget as well. Each WebTarget instance inherits a configuration from it's parent (either a client or another web target) and can be further custom-configured without affecting the configuration of the parent component. In this case, the FilterForExampleCom will be registered only in the webTarget and not in client. So, the client can still be used to create new WebTarget instances pointing at other URIs using just the common client configuration, which FilterForExampleCom filter is not part of.

5.3.4. 用WebTarget识别资源

5.3.4. Identifying resource on WebTarget

假设我们有一个webTarget指向“http://example.com/rest”URI表示一个RESTful应用程序的上下文根和有一个资源暴露在URI“http://example.com/rest/resource”。如前所述，一个WebTarget实例可以用于派生其他web目标。使用下面的代码来定义资源的路径。
WebTarget resourceWebTarget = webTarget.path("resource");

Let's assume we have a webTarget pointing at "http://example.com/rest" URI that represents a context root of a RESTful application and there is a resource exposed on the URI "http://example.com/rest/resource". As already mentioned, a WebTarget instance can be used to derive other web targets. Use the following code to define a path to the resource.
WebTarget resourceWebTarget = webTarget.path("resource");

现在resourceWebTarget指向资源URI“http://example.com/rest/resource”。同样，如果我们对这个resource配置特定的过滤器resourceWebTarget，它将不会影响原始的webTarget实例。然而，过滤器FilterForExampleCom注册仍将由resourceWebTarget继承，因为它是由webTarget创建的。该机制允许您共享相关资源的公共配置(通常在同一个URI根下，在我们的例子中由webTarget实例提供)，同时允许基于每个单独资源的特定需求进行进一步的专门化配置。继承的相同配置原则(允许常见的配置传播)和分离(允许单独的配置定制)适用于下面讨论的JAX-RS Client API中的所有组件。

The resourceWebTarget now points to the resource on URI "http://example.com/rest/resource". Again if we configure the resourceWebTarget with a filter specific to the resource, it will not influence the original webTarget instance. However, the filter FilterForExampleCom registration will still be inherited by the resourceWebTarget as it has been created from webTarget. This mechanism allows you to share the common configuration of related resources (typically hosted under the same URI root, in our case represented by the webTarget instance), while allowing for further configuration specialization based on the specific requirements of each individual resource. The same configuration principles of inheritance (to allow common config propagation) and decoupling (to allow individual config customization) applies to all components in JAX-RS Client API discussed below.

假设有一子资源的道路上“http://example.com/rest/resource/helloworld”。你可以通过以下简单的方式为该资源派生一个WebTarget:
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");

Let's say there is a sub resource on the path "http://example.com/rest/resource/helloworld". You can derive a WebTarget for this resource simply by:
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");

让我们假设helloworld资源为定义欢迎消息的 GET 请求接受一个查询参数。接下来的代码片段显示了一个创建带有定义了查询参数的新WebTarget代码。
WebTarget helloworldWebTargetWithQueryParam = helloworldWebTarget.queryParam("greeting", "Hi World!");

Let's assume that the helloworld resource accepts a query param for GET requests which defines the greeting message. The next code snippet shows a code that creates a new WebTarget with the query param defined.
WebTarget helloworldWebTargetWithQueryParam = helloworldWebTarget.queryParam("greeting", "Hi World!");

请注意，除了可以根据URI路径或查询参数派生新的WebTarget实例的方法之外，JAX-RS WebTarget API还包含了使用矩阵参数的方法。

Please note that apart from methods that can derive new WebTarget instance based on a URI path or query parameters, the JAX-RS WebTarget API contains also methods for working with matrix parameters too.

5.3.5. 调用一个HTTP请求

5.3.5. Invoking a HTTP request

现在，让我们关注于在创建的web targets上调用一个GET HTTP请求。要开始构建新的HTTP请求调用，我们需要创建一个新的 Invocation.Builder。
Invocation.Builder invocationBuilder =helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);invocationBuilder.header("some-header", "true");

Let's now focus on invoking a GET HTTP request on the created web targets. To start building a new HTTP request invocation, we need to create a new Invocation.Builder.
Invocation.Builder invocationBuilder = helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);invocationBuilder.header("some-header", "true");

一个新的invocation builder实例是使用WebTarget上可用的request(...) 方法之一创建的。其中一些方法接受参数，让你定义从资源返回的请求要表示形式的媒体类型。在这里，我们说我们请求一个“text / plain”类型。这告诉Jersey添加一个Accept:text / plain HTTP头，以满足我们的请求。

A new invocation builder instance is created using one of the request(...) methods that are available on WebTarget. A couple of these methods accept parameters that let you define the media type of the representation requested to be returned from the resource. Here we are saying that we request a "text/plain" type. This tells Jersey to add a Accept: text/plain HTTP header to our request.

invocationBuilder用于设置request的特定的参数。在这里，我们可以为request设置headers，或者例如cookie参数。在我们的示例中，我们设置了一个值为true的“some- header”请求头。

The invocationBuilder is used to setup request specific parameters. Here we can setup headers for the request or for example cookie parameters. In our example we set up a "some-header" header to value true.

一旦完成了request 定制，就该调用request了。我们现在有两种选择。我们可以使用Invocation.Builder构建一个将稍后调用的通用Invocation 实例。使用Invocation，我们可以，例如在批量的request中设置额外的request 属性，并使用通用的JAX-RS Invocation API去调用这些不需要知道所有的细节的批量的request (比如request HTTP方法、配置等)。在request 处理过程中，可以读取在invocation 实例上设置的任何属性。例如，在自定义ClientRequestFilter中，你可以在提供的ClientRequestContext上调用getProperty()方法来读取request 属性。注意，这些request 属性不同于Configurable配置属性。正如前面提到的，一个Invocation实例提供了一个通用调用API来调用它所代表的HTTP请求，要么是同步的，要么是异步的。有关异步调用的更多信息，请参见第11章. 异步服务和客户机。

Once finished with request customizations, it's time to invoke the request. We have two options now. We can use the Invocation.Builder to build a generic Invocation instance that will be invoked some time later. Using Invocation we will be able to e.g. set additional request properties which are properties in a batch of several requests and use the generic JAX-RS Invocation API to invoke the batch of requests without actually knowing all the details (such as request HTTP method, configuration etc.). Any properties set on an invocation instance can be read during the request processing. For example, in a custom ClientRequestFilter you can call getProperty() method on the supplied ClientRequestContext to read a request property. Note that these request properties are different from the configuration properties set on Configurable. As mentioned earlier, an Invocation instance provides generic invocation API to invoke the HTTP request it represents either synchronously or asynchronously. See the Chapter 11, Asynchronous Services and Clients for more information on asynchronous invocations.

如果你不想在调用你的HTTP请求装置之前执行任何批处理，那么你可以使用另一种更方便的方法从 Invocation.Builder 实例直接调用你的request。此方法在接下来的Java代码清单中演示。
Response response = invocationBuilder.get();

In case you do not want to do any batch processing on your HTTP request invocations prior to invoking them, there is another, more convenient approach that you can use to invoke your requests directly from an Invocation.Builder instance. This approach is demonstrated in the next Java code listing.
Response response = invocationBuilder.get();

尽管如此，示例中的代码执行多个操作。首先，它将由invocationBuilder构建request 。request 的URI将会是http://example.com/rest/resource/helloworld?greeting=”Hi%20World!”并且request 将包含请求头 some-header: true and Accept: text/plain 。然后请求将传递到所有配置的请求过滤器(AnotherClientFilter, ThirdClientFilter and FilterForExampleCom)。一旦经过这些过滤器处理，请求将被发送到远程资源。假设资源返回一个带有纯文本响应内容的HTTP 200消息，其中包含请求中发送的greeting查询参数的值。现在我们可以观察返回的响应:
System.out.println(response.getStatus());System.out.println(response.readEntity(String.class));

While short, the code in the example performs multiple actions. First, it will build the the request from the invocationBuilder. The URI of request will be http://example.com/rest/resource/helloworld?greeting="Hi%20World!" and the request will contain some-header: true and Accept: text/plain headers. The request will then pass trough all configured request filters ( AnotherClientFilter, ThirdClientFilter and FilterForExampleCom). Once processed by the filters, the request will be sent to the remote resource. Let's say the resource then returns an HTTP 200 message with a plain text response content that contains the value sent in the request greeting query parameter. Now we can observe the returned response:
System.out.println(response.getStatus());System.out.println(response.readEntity(String.class));

控制台将产生以下输出:
200
Hi World!

which will produce the following output to the console:
200
Hi World!

如我们所见，请求被成功处理(状态码 200)并返回一个实体(表示)是“Hi World !”。注意,因为我们已经 在resource target中配置了一个MyClientResponseFilter,当response.readEntity(String.class)被调用时,从远程端点返回的response 通过响应过滤器链(包括MyClientResponseFilter)和实体拦截器链和最后一个适当的MessageBodyReader<T>被用于从响应流将响应内容字节读出为一个Java字符串实例。检查第10章. 过滤器和拦截器，以了解更多关于请求和响应过滤器和实体拦截器。

As we can see, the request was successfully processed (code 200) and returned an entity (representation) is "Hi World!". Note that since we have configured a MyClientResponseFilter in the resource target, when response.readEntity(String.class) gets called, the response returned from the remote endpoint is passed through the response filter chain (including the MyClientResponseFilter) and entity interceptor chain and at last a proper MessageBodyReader<T> is located to read the response content bytes from the response stream into a Java String instance. Check Chapter 10, Filters and Interceptors to lear more about request and response filters and entity interceptors.

假设您想调用POST请求，但是没有任何查询参数。您只需使用前面创建的helloworldWebTarget实例，并调用post()而不是get()。
Response postResponse =helloworldWebTarget.request(MediaType.TEXT_PLAIN_TYPE).post(Entity.entity("A string entity to be POSTed", MediaType.TEXT_PLAIN));

Imagine now that you would like to invoke a POST request but without any query parameters. You would just use the helloworldWebTarget instance created earlier and call the post() instead of get().
Response postResponse = helloworldWebTarget.request(MediaType.TEXT_PLAIN_TYPE) .post(Entity.entity("A string entity to be POSTed", MediaType.TEXT_PLAIN));

5.3.6. 例子总结

5.3.6. Example summary

下面的代码将前面示例中使用的片段组合在一起。
例 5.2. 用 JAX-RS Client API
ClientConfig clientConfig = new ClientConfig();clientConfig.register(MyClientResponseFilter.class);clientConfig.register(new AnotherClientFilter());Client client = ClientBuilder.newClient(clientConfig);client.register(ThirdClientFilter.class);WebTarget webTarget = client.target("http://example.com/rest");webTarget.register(FilterForExampleCom.class);WebTarget resourceWebTarget = webTarget.path("resource");WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");WebTarget helloworldWebTargetWithQueryParam =helloworldWebTarget.queryParam("greeting", "Hi World!");Invocation.Builder invocationBuilder =helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);invocationBuilder.header("some-header", "true");Response response = invocationBuilder.get();System.out.println(response.getStatus());System.out.println(response.readEntity(String.class));

The following code puts together the pieces used in the earlier examples.
Example 5.2. Using JAX-RS Client API
ClientConfig clientConfig = new ClientConfig();clientConfig.register(MyClientResponseFilter.class);clientConfig.register(new AnotherClientFilter());Client client = ClientBuilder.newClient(clientConfig);client.register(ThirdClientFilter.class);WebTarget webTarget = client.target("http://example.com/rest");webTarget.register(FilterForExampleCom.class);WebTarget resourceWebTarget = webTarget.path("resource");WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");WebTarget helloworldWebTargetWithQueryParam =helloworldWebTarget.queryParam("greeting", "Hi World!");Invocation.Builder invocationBuilder =helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);invocationBuilder.header("some-header", "true");Response response = invocationBuilder.get();System.out.println(response.getStatus());System.out.println(response.readEntity(String.class));

现在，我们可以尝试利用流式API风格以一种更紧凑的方式编写代码。
例 5.3. 流式 JAX-RS Client API
Client client = ClientBuilder.newClient(new ClientConfig().register(MyClientResponseFilter.class).register(new AnotherClientFilter()));String entity = client.target("http://example.com/rest").register(FilterForExampleCom.class).path("resource/helloworld").queryParam("greeting", "Hi World!").request(MediaType.TEXT_PLAIN_TYPE).header("some-header", "true").get(String.class);

Now we can try to leverage the fluent API style to write this code in a more compact way.
Example 5.3. Using JAX-RS Client API fluently
Client client = ClientBuilder.newClient(new ClientConfig() .register(MyClientResponseFilter.class) .register(new AnotherClientFilter())); String entity = client.target("http://example.com/rest") .register(FilterForExampleCom.class) .path("resource/helloworld") .queryParam("greeting", "Hi World!") .request(MediaType.TEXT_PLAIN_TYPE) .header("some-header", "true") .get(String.class);

上面的代码做了同样的事情，只是它跳过了一般Response的处理过程，并在最后一个get(String.class)方法调用中直接请求一个实体。这个快捷方法让我们指定(如果响应成功地返回了HTTP 2xx状态码)响应实体应作为Java String 类型返回。这个紧凑的示例展示了JAX-RS client API的另一个优点。JAX-RS client API的流畅度用于简单的用例是相当实用的。这里还有一个非常简单的GET请求返回一个字符串表示(实体):
String responseEntity = ClientBuilder.newClient() .target("http://example.com").path("resource/rest") .request().get(String.class);

The code above does the same thing except it skips the generic Response processing and directly requests an entity in the last get(String.class) method call. This shortcut method let's you specify that (in case the response was returned successfully with a HTTP 2xx status code) the response entity should be returned as Java String type. This compact example demonstrates another advantage of the JAX-RS client API. The fluency of JAX-RS Client API is convenient especially with simple use cases. Here is another a very simple GET request returning a String representation (entity):
String responseEntity = ClientBuilder.newClient() .target("http://example.com").path("resource/rest") .request().get(String.class);

5.3.7. 设置ExecutorService和ScheduledExecutorService

5.3.7. Setting ExecutorService and ScheduledExecutorService

一些客户端调用，如异步或被动调用，可能导致需要启动新的线程。这是做ExecutorService 或ScheduledExecutorService. ClientBuilder有两种方法，可以用来定义它们: executorService(executorService)和scheduledExecutorService(scheduledExecutorService)。当指定的所有调用都需要在另一个线程上运行时，应该使用提供的服务来执行。

Some client invocations, like asynchronous or reactive, could lead to a need to start a new thread. This is being done on provided ExecutorService or ScheduledExecutorService. ClientBuilder has two methods, which can be used to define them: executorService(ExecutorService) and scheduledExecutorService(ScheduledExecutorService). When specified, all invocations which do require running on another thread, should be executed using provided services.

默认值取决于环境——Java EE容器中,它必须是ManagedExecutorService和ManagedScheduledExecutorService，在Java SE中，它是Executor服务的ForkJoinPool.commonPool和 Scheduled执行者服务未定义的某些东西。
例e 5.4. 设置 JAX-RS Client ExecutorService
ExecutorService myExecutorService = Executors.newCachedThreadPool();Client client = ClientBuilder.newBuilder().executorService(myExecutorService).build();

Default values do depend on the environment - in Java EE container, it has to be ManagedExecutorService and ManagedScheduledExecutorService, for Java SE it would be ForkJoinPool.commonPool for Executor service and something undefined for Scheduled executor service.
Example 5.4. Setting JAX-RS Client ExecutorService
ExecutorService myExecutorService = Executors.newCachedThreadPool();Client client = ClientBuilder.newBuilder().executorService(myExecutorService).build();

5.4. 表示的Java实例和类型

5.4. Java instances and types for representations

在Jersey服务器端为请求和响应默认支持的所有Java类型和表示，客户端也支持。例如，下面这样使用InputStream像一个字节流处理一个响应实体(或表示):
InputStream in = response.readEntity(InputStream.class);... // 从流中读取in.close();

All the Java types and representations supported by default on the Jersey server side for requests and responses are also supported on the client side. For example, to process a response entity (or representation) as a stream of bytes use InputStream as follows:
InputStream in = response.readEntity(InputStream.class); ... // Read from the stream in.close();

注意，在处理后关闭流是很重要的，以便释放资源。

Note that it is important to close the stream after processing so that resources are freed up.

要 POST 文件，使用 File 实例如下:
File f = ... ... webTarget.request().post(Entity.entity(f, MediaType.TEXT_PLAIN_TYPE));

> To POST a file use a File instance as follows:
> File f = ... ... webTarget.request().post(Entity.entity(f, MediaType.TEXT_PLAIN_TYPE));

5.4.1. 添加对新表示的支持

> 5.4.1. Adding support for new representations

新的应用程序定义的表示作为Java类型的支持需要为服务器端JAX-RS API相同的JAX-RS实体提供者扩展接口的实现，分别名为MessageBodyReader<T>和MessageBodyWriter<T>，用于请求和响应实体(或入站和出站表示)。

> The support for new application-defined representations as Java types requires the implementation of the same JAX-RS entity provider extension interfaces as for the server side JAX-RS API, namely MessageBodyReader<T> and MessageBodyWriter<T> respectively, for request and response entities (or inbound and outbound representations).

基于提供者接口的类或实现需要注册为类似前面章节所示在 JAX-RS 或Jersey Client API之中实现Configurable 约束(ClientBuilder、Client、WebTarget或ClientConfig)的组件的提供者。一些在JAX-RS Feature 的表单中媒体类型提供一种概念允许扩展提供者将多个不同的扩展提供者和/或配置属性组合在一起，以简化由最终用户提供特性的注册和配置。例如，MoxyJsonFeature可以通过MOXy库注册，以启用和配置JSON绑定支持。

> Classes or implementations of the provider-based interfaces need to be registered as providers within the JAX-RS or Jersey Client API components that implement Configurable contract (ClientBuilder, Client, WebTarget or ClientConfig), as was shown in the earlier sections. Some media types are provided in the form of JAX-RS Feature a concept that allows the extension providers to group together multiple different extension providers and/or configuration properties in order to simplify the registration and configuration of the provided feature by the end users. For example, MoxyJsonFeature can be register to enable and configure JSON binding support via MOXy library.

5.5. 客户端传输连接器
> 5.5. Client Transport Connectors

默认情况下，Jersey中的传输层由HttpUrlConnection提供。这种传输是通过HttpUrlConnectorProvider在Jersey实现的，它实现了特定于Jersey的连接器SPI。您可以实现和/或将自己的Connector 实例注册到Jersey Client 实现中，这将替换默认的httpurlconnectionbased传输层。Jersey提供了几种可供选择的客户机传输连接器实现随时可用。
表 5.1. Jersey 连接器列表
传输框架 Jersey 连接器实现 Maven 依赖
Grizzly NIO framework GrizzlyConnectorProvider org.glassfish.jersey.connectors:jersey-grizzly-connector
Apache HTTP client ApacheConnectorProvider org.glassfish.jersey.connectors:jersey-apache-connector
Jetty HTTP client JettyConnectorProvider org.glassfish.jersey.connectors:jersey-jetty-connector
Netty NIO framework NettyConnectorProvider org.glassfish.jersey.connectors:jersey-netty-connector
JDK NIO client JdkConnectorProvider org.glassfish.jersey.connectors:jersey-jdk-connector

> By default, the transport layer in Jersey is provided by HttpUrlConnection. This transport is implemented in Jersey via HttpUrlConnectorProvider that implements Jersey-specific Connector SPI. You can implement and/or register your own Connector instance to the Jersey Client implementation, that will replace the default HttpUrlConnection-based transport layer. Jersey provides several alternative client transport connector implementations that are ready-to-use.
> Table 5.1. List of Jersey Connectors
> Transport framework Jersey Connector implementation Maven dependency
> Grizzly NIO framework GrizzlyConnectorProvider org.glassfish.jersey.connectors:jersey-grizzly-connector
> Apache HTTP client ApacheConnectorProvider org.glassfish.jersey.connectors:jersey-apache-connector
> Jetty HTTP client JettyConnectorProvider org.glassfish.jersey.connectors:jersey-jetty-connector
> Netty NIO framework NettyConnectorProvider org.glassfish.jersey.connectors:jersey-netty-connector
> JDK NIO client JdkConnectorProvider org.glassfish.jersey.connectors:jersey-jdk-connector

警告
> Warning
注意不要使用默认的连接器实现。在WriterInterceptor或MessageBodyWriter<T>中有一个处理HTTP header的问题。如果您需要更改header字段，请不要使用或ApacheConnectorProvider或GrizzlyConnectorProvider或JettyConnectorProvider，更不是NettyConnectorProvider。这个问题也适用于Jersey Multipart特性，它也会修改HTTP头信息。

> Be aware of using other than default Connector implementation. There is an issue handling HTTP headers in WriterInterceptor or MessageBodyWriter<T>. If you need to change header fields do not use nor ApacheConnectorProvider nor GrizzlyConnectorProvider nor JettyConnectorProvider neither NettyConnectorProvider. The issue for example applies to Jersey Multipart feature that also modifies HTTP headers.

另一方面，在默认的传输连接器中，在header中有一些限制，可以在默认配置中发送。HttpUrlConnectorProvider使用HttpUrlConnection作为底层连接实现。这个JDK类默认限制了下列header的使用:
- Access-Control-Request-Headers
- Access-Control-Request-Method
- Connection (有一个例外，有 - Connection而且值是Closed 的header 默认情况下是允许的)
- Content-Length
- Content-Transfer-Encoding -
- Host
- Keep-Alive
- Origin
- Trailer
- Transfer-Encoding
- Upgrade
- Via
- 以Sec-开头的所有的header

> On the other hand, in the default transport connector, there are some restrictions on the headers, that can be sent in the default configuration. HttpUrlConnectorProvider uses HttpUrlConnection as an underlying connection implementation. This JDK class by default restricts the use of following headers:
> - Access-Control-Request-Headers
> - Access-Control-Request-Method
> - Connection (with one exception - Connection header with value Closed is allowed by default)
> - Content-Length
> - Content-Transfer-Encoding-
> - Host
> - Keep-Alive
> - Origin
> - Trailer
> - Transfer-Encoding
> - Upgrade
> - Via
> - all the headers starting with Sec-

底层连接可以配置为允许所有头文件被发送,但是这种行为只有通过设置系统属性sun.net.http.allowRestrictedHeaders可以被
改变。
例 5.5. 使用HttpUrlConnector发送受限制的header 
Client client = ClientBuilder.newClient();System.setProperty("sun.net.http.allowRestrictedHeaders", "true"); Response response = client.target(yourUri).path(yourPath).request().header("Origin", "http://example.com").header("Access-Control-Request-Method", "POST").get();

> The underlying connection can be configured to permit all headers to be sent, however this behaviour can be changed only by setting the system property sun.net.http.allowRestrictedHeaders.
> Example 5.5. Sending restricted headers with HttpUrlConnector
> Client client = ClientBuilder.newClient();System.setProperty("sun.net.http.allowRestrictedHeaders", "true"); Response response = client.target(yourUri).path(yourPath).request().header("Origin", "http://example.com").header("Access-Control-Request-Method", "POST").get();

注意，内部地HttpUrlConnection实例的是合并到一起的，因此通常在已创建目标后（不）设置属性不会产生任何效果。属性影响在属性已被（不）设置之后创建的所有连接，但是没有保证，你的请求将使用在属性更改后创建的连接。
> Note, that internally the HttpUrlConnection instances are pooled, so (un)setting the property after already creating a target typically does not have any effect. The property influences all the connections created after the property has been (un)set, but there is no guarantee, that your request will use a connection created after the property change.

在简单的环境中,在创建第一个目标前设置属性就足够了,但在复杂环境中(比如应用服务器),一些可池化的连接甚至可能存在在你的应用程序甚至加载器之前,这种方法并不是100%可靠,同时我们建议使用一个不同的客户端传输连接器,例如 Apache Connector。这些限制必须被考虑，特别是在调用CORS(Cross Origin Resource Sharing，跨源资源共享)请求时。

> In a simple environment, setting the property before creating the first target is sufficient, but in complex environments (such as application servers), where some poolable connections might exist before your application even bootstraps, this approach is not 100% reliable and we recommend using a different client transport connector, such as Apache Connector. These limitations have to be considered especially when invoking CORS (Cross Origin Resource Sharing) requests.

如前所述，Connector 和ConnectorProvider约束是特定于Jersey的扩展API，它只会与Jersey一起工作，因为它本身不是 JAX-RS的一部分。下面的示例演示了如何在Jersey客户端实例中设置自定义的基于ConnectorProvider 的Grizzly Asynchronous HTTP Client连接程序。
ClientConfig clientConfig = new ClientConfig();clientConfig.connectorProvider(new GrizzlyConnectorProvider());Client client = ClientBuilder.newClient(clientConfig);

> As indicated earlier, Connector and ConnectorProvider contracts are Jersey-specific extension APIs that would only work with Jersey and as such are not part of JAX-RS. Following example shows how to setup the custom Grizzly Asynchronous HTTP Client based ConnectorProvider in a Jersey client instance:
> ClientConfig clientConfig = new ClientConfig();clientConfig.connectorProvider(new GrizzlyConnectorProvider());Client client = ClientBuilder.newClient(clientConfig);

Client 接受作为一个构造函数参数的Configurable 实例。为客户机的Configurable 提供者的Jersey实现的是ClientConfig。通过使用Jersey ClientConfig，您可以将自定义的ConnectorProvider配置到ClientConfig中。上面的例子中的GrizzlyConnectorProvider 被当作一个自定义连接器提供者。请注意，连接器提供者不能用Configurable.register(…)注册为提供者。另外，请注意，这个API在Jersey 2.5中已经发生了变化，在这里引入的ConnectorProvider SPI，以便将客户端初始化从连接器实例化中解除耦合。从Jersey 2.5开始因此不可能的在Jersey ClientConfig中直接注册Connector 实例。新的ConnectorProvider SPI必须被用来配置定制的客户端传输连接器。

> Client accepts as as a constructor argument a Configurable instance. Jersey implementation of the Configurable provider for the client is ClientConfig. By using the Jersey ClientConfig you can configure the custom ConnectorProvider into the ClientConfig. The GrizzlyConnectorProvider is used as a custom connector provider in the example above. Please note that the connector provider cannot be registered as a provider using Configurable.register(...). Also, please note that in this API has changed in Jersey 2.5, where the ConnectorProvider SPI has been introduced in order to decouple client initialization from the connector instantiation. Starting with Jersey 2.5 it is therefore not possible to directly register Connector instances in the Jersey ClientConfig. The new ConnectorProvider SPI must be used instead to configure a custom client-side transport connector.

5.6. 使用客户端请求和响应过滤器

> 5.6. Using client request and response filters

过滤请求和响应可以提供有用的低级别的关注于某个独立的方面或领域的概念，它们与构建和发送请求和处理响应的应用程序层分离。过滤器可以读取/修改请求URI、头和实体，或读取/修改响应状态、头和实体。

> Filtering requests and responses can provide useful lower-level concept focused on a certain independent aspect or domain that is decoupled from the application layer of building and sending requests, and processing responses. Filters can read/modify the request URI, headers and entity or read/modify the response status, headers and entity.

Jersey包含以下有用的客户端过滤器(以及注册过滤器的特性)，您可以在应用程序中使用它们:
CsrfProtectionFilter:跨站点请求伪造保护过滤器(给每个状态更改请求增加X-Requested-By)。
EncodingFeature:寄存器编码过滤器的特性，它使用注册的ContentEncoders来对通信进行编码和解码。编码/解码是在拦截器中执行的(您不需要注册这个拦截器)。检查EncodingFeature的javadoc以使用它。
HttpAuthenticationFeature:HTTP身份验证特性(见? ? ?下文)。


> Jersey contains the following useful client-side filters (and features registering filters) that you may want to use in your applications:
> CsrfProtectionFilter: Cross-site request forgery protection filter (adds X-Requested-By to each state changing request).
> EncodingFeature: Feature that registers encoding filter which use registered ContentEncoders to encode and decode the communication. The encoding/decoding is performed in interceptor (you don't need to register this interceptor). Check the javadoc of the EncodingFeature in order to use it.
> HttpAuthenticationFeature: HTTP Authentication Feature (see ??? below).

请注意，这些特性是由Jersey提供的，但是由于它们使用和实现JAX-RS API，所以这些特性应该是可移植的，并且在任何 JAX-RS 实现中运行，而不仅仅是Jersey。有关过滤器和拦截器的更多信息，请参阅第10章、过滤器和拦截器章节。

> Note that these features are provided by Jersey, but since they use and implement JAX-RS API, the features should be portable and run in any JAX-RS implementation, not just Jersey. See Chapter 10, Filters and Interceptors chapter for more information on filters and interceptors.

5.7. 关闭连接

> 5.7. Closing connections

在接收到响应并处理实体(读取实体)后，为每个请求打开底层连接并关闭。看下面的例子:
例 5.6. 关闭连接
final WebTarget target = ... some web targetResponse response = target.path("resource").request().get();System.out.println("Connection is still open.");System.out.println("string response: " + response.readEntity(String.class));System.out.println("Now the connection is closed.");

> The underlying connections are opened for each request and closed after the response is received and entity is processed (entity is read). See the following example:
> Example 5.6. Closing connections
> final WebTarget target = ... some web targetResponse response = target.path("resource").request().get();System.out.println("Connection is still open.");System.out.println("string response: " + response.readEntity(String.class));System.out.println("Now the connection is closed.");

如果您不读取该实体，则需要通过response.close()手动关闭响应。另外，如果将实体读入InputStream(由response.readEntity(InputStream.class))，则连接将保持打开，直到从输入流中读取为止。在这种情况下，InputStream或响应应该在InputStream的末尾手动关闭。

> If you don't read the entity, then you need to close the response manually by response.close(). Also if the entity is read into an InputStream (by response.readEntity(InputStream.class)), the connection stays open until you finish reading from the InputStream. In that case, the InputStream or the Response should be closed manually at the end of reading from InputStream.

5.8. 注入客户的供应商

> 5.8. Injections into client providers

在某些情况下，您可能需要在您的客户端提供者实例中注入一些自定义类型。jax - rs类型不需要被注入，因为它们作为参数传递给API方法。只要提供者注册为类，就可以向客户机提供程序(过滤器、拦截器)注入。如果提供者被注册为实例，那么运行时将不会注入提供者。原因是这个提供者实例可能被注册到多个客户机配置中。例如，ClientRequestFilter的一个实例可以注册为两个客户机。

> In some cases you might need to inject some custom types into your client provider instance. JAX-RS types do not need to be injected as they are passed as arguments into API methods. Injections into client providers (filters, interceptor) are possible as long as the provider is registered as a class. If the provider is registered as an instance then runtime will not inject the provider. The reason is that this provider instance might be registered into multiple client configurations. For example one instance of ClientRequestFilter can be registered to two Clients.

解决自定义类型的注入到一个客户端提供者实例使用ServiceLocatorClientProvider提取ServiceLocator可以返回所需的注射。下面的例子展示了如何利用ServiceLocatorClientProvider:
例 5.7. ServiceLocatorClientProvider 用例
public static class MyRequestFilter implements ClientRequestFilter {// 此注入不作为过滤器工作，以作为实例注册:// @Inject// private MyInjectedService service;@Overridepublic void filter(ClientRequestContext requestContext) throws IOException {// 使用ServiceLocatorClientProvider提取HK2 ServiceLocator的请求final ServiceLocator locator = ServiceLocatorClientProvider.getServiceLocator(requestContext);// 并要求MyInjectedService: final MyInjectedService service = locator.getService(MyInjectedService.class);final String name = service.getName();...}}

> To solve injection of a custom type into a client provider instance use ServiceLocatorClientProvider to extract ServiceLocator which can return the required injection. The following example shows how to utilize ServiceLocatorClientProvider:
> Example 5.7. ServiceLocatorClientProvider example
> public static class MyRequestFilter implements ClientRequestFilter { // this injection does not work as filter is registered as an instance: // @Inject // private MyInjectedService service;  @Override public void filter(ClientRequestContext requestContext) throws IOException { // use ServiceLocatorClientProvider to extract HK2 ServiceLocator from request final ServiceLocator locator = ServiceLocatorClientProvider.getServiceLocator(requestContext);  // and ask for MyInjectedService: final MyInjectedService service = locator.getService(MyInjectedService.class);  final String name = service.getName(); ... }}

更多信息见javadoc ServiceLocatorClientProvider(和javadoc ServiceLocatorProvider支持常见的jax - rs组件)。

> For more information see javadoc of ServiceLocatorClientProvider (and javadoc of ServiceLocatorProvider which supports common JAX-RS components).

5.9. 确保客户端

> 5.9. Securing a Client

本节描述如何在Jersey客户机上设置SSL配置(使用jax - rs API)。SSL配置是在ClientBuilder中设置的。客户端构建器包含用于定义密钥库、信任库或整个SslContext的方法。看下面的例子:
SSLContext ssl = ... your configured SSL context;Client client = ClientBuilder.newBuilder().sslContext(ssl).build();Response response = client.target("https://example.com/resource").request().get();

> This section describes how to setup SSL configuration on Jersey client (using JAX-RS API). The SSL configuration is setup in ClientBuilder. The client builder contains methods for definition of KeyStore, TrustStore or entire SslContext. See the following example:
> SSLContext ssl = ... your configured SSL context;Client client = ClientBuilder.newBuilder().sslContext(ssl).build();Response response = client.target("https://example.com/resource").request().get();

上面的示例演示了如何为ClientBuilder设置自定义SslContext。创建SslContext可能更加困难，因为您可能需要对协议、密钥存储库、信任库等进行适当的init实例。Jersey提供了一个实用工具SslConfigurator类，可以用来设置SslContext。可以根据SSL配置的标准化系统属性配置SslConfigurator，例如，您可以使用环境变量javax . net . net . ssl.keystore和SslConfigurator来配置KeyStore文件名，然后使用这样的变量来设置SslContext。有关更多细节，请参见SslConfigurator的javadoc。下面的代码展示了如何使用SslConfigurator创建自定义SSL上下文。
SslConfigurator sslConfig = SslConfigurator.newInstance().trustStoreFile("./truststore_client").trustStorePassword("secret-password-for-truststore").keyStoreFile("./keystore_client").keyPassword("secret-password-for-keystore");SSLContext sslContext = sslConfig.createSSLContext();Client client = ClientBuilder.newBuilder().sslContext(sslContext).build();

> The example above shows how to setup a custom SslContext to the ClientBuilder. Creating a SslContext can be more difficult as you might need to init instance properly with the protocol, KeyStore, TrustStore, etc. Jersey offers a utility SslConfigurator class that can be used to setup the SslContext. The SslConfigurator can be configured based on standardized system properties for SSL configuration, so for example you can configure the KeyStore file name using a environment variable javax.net.ssl.keyStore and SslConfigurator will use such a variable to setup the SslContext. See javadoc of SslConfigurator for more details. The following code shows how a SslConfigurator can be used to create a custom SSL context.
> SslConfigurator sslConfig = SslConfigurator.newInstance() .trustStoreFile("./truststore_client") .trustStorePassword("secret-password-for-truststore") .keyStoreFile("./keystore_client") .keyPassword("secret-password-for-keystore"); SSLContext sslContext = sslConfig.createSSLContext();Client client = ClientBuilder.newBuilder().sslContext(sslContext).build();

注意，您还可以直接在ClientBuilder实例上设置密钥存储库和信任存储库，而无需将它们封装到SslContext中。但是，如果设置SslContext，它将覆盖之前定义的密钥存储库和信任存储设置。ClientBuilder还提供了一种定义定制HostnameVerifier实现的方法。当缺省主机URL验证失败时，将调用HostnameVerifier实现。

> Note that you can also setup KeyStore and TrustStore directly on a ClientBuilder instance without wrapping them into the SslContext. However, if you setup a SslContext it will override any previously defined KeyStore and TrustStore settings. ClientBuilder also offers a method for defining a custom HostnameVerifier implementation. HostnameVerifier implementations are invoked when default host URL verification fails.

重要的
HostnameVerifier的行为依赖于http客户端实现。HttpUrlConnectorProvider和ApacheConnectorProvider工作正常，这意味着在失败的URL验证HostnameVerifier被调用之后，通过使用HostnameVerifier的自定义实现来重新验证URL，并在handskahe处理中继续进行。JettyConnectorProvider和GrizzlyConnectorProvider只提供主机URL验证，并抛出一个证书异常，但不可能使用定制的HostnameVerifier。此外，在JettyConnectorProvider的情况下，有一个属性JettyClientProperties。enable_ssl_hostname_验证可以在握手时禁用整个主机URL验证机制。

> Important
> A behaviour of HostnameVerifier is dependent on an http client implementation. HttpUrlConnectorProvider and ApacheConnectorProvider work properly, that means that after the unsuccessful URL verification HostnameVerifier is called and by means of it is possible to revalidate URL using a custom implementation of HostnameVerifier and go on in a handskahe processing. JettyConnectorProvider and GrizzlyConnectorProvider provide only host URL verification and throw a CertificateException without any possibility to use custom HostnameVerifier. Moreover, in case of JettyConnectorProvider there is a property JettyClientProperties.ENABLE_SSL_HOSTNAME_VERIFICATION to disable an entire host URL verification mechanism in a handshake.

重要的
注意，要使用带有SSL的HTTP，就必须使用“https”方案。
目前默认连接器提供者HttpUrlConnectorProvider提供基于HttpUrlConnection的连接器，该连接器实现了在本例中讨论的jax - rs配置定义的SSL的支持。

> Important
> Note that to utilize HTTP with SSL it is necessary to utilize the “https” scheme.
> Currently the default connector provider HttpUrlConnectorProvider provides connectors based on HttpUrlConnection which implement support for SSL defined by JAX-RS configuration discussed in this example.

5.9.1. Http身份验证的支持
Jersey支持基本的和摘要的HTTP身份验证。

> 5.9.1. Http Authentication Support
> Jersey supports Basic and Digest HTTP Authentication.

重要的
在 Jersey 2.5 之前版本中所提供的支持是org.glassfish.jersey.client.filter.HttpBasicAuthFilter 和org.glassfish.jersey.client.filter.HttpDigestAuthFilter。因为Jersey 2.5这些过滤器被弃用了(在2.6中被移除)和HttpAuthenticationFeature身份验证方法都是由单一功能。

> Important
> In version prior to Jersey 2.5 the support was provided by org.glassfish.jersey.client.filter.HttpBasicAuthFilter and org.glassfish.jersey.client.filter.HttpDigestAuthFilter. Since Jersey 2.5 these filters are deprecated (and removed in 2.6) and both authentication methods are provided by single Feature HttpAuthenticationFeature.

为了启用http身份验证支持Jersey客户端注册HttpAuthenticationFeature。该特性可以同时提供身份验证方法、摘要和基本功能。功能可以在以下模式下工作:
- 基本:基本先发制人的身份验证。在抢占模式下，认证信息总是随每个HTTP请求发送。这种模式比下面的非抢占模式更为常见(如果您需要基本身份验证，您可能会使用这种抢占模式)。此模式必须与SSL / TLS的使用相结合，因为密码只发送BASE64编码。
- 基本没有采用基于优先级的设计:基本无优先的验证策略。在非抢占模式中，只有当服务器以401状态码拒绝请求时才添加身份验证信息，然后再用身份验证信息重复请求。这种模式对性能有负面影响。它的优点是，当它们不需要时，它不发送凭证。此模式必须与SSL / TLS的使用相结合，因为密码只发送BASE64编码。
- 消化:Http摘要认证。不需要使用SSL / TLS。
- 普遍:基本和摘要式身份验证。该特性以非抢占模式工作，这意味着它在没有身份验证信息的情况下发送请求。如果返回401状态代码，则会重复请求，并根据响应中请求的身份验证使用适当的身份验证(在www - authenticate HTTP头中定义)。该特性会记住哪些身份验证请求对给定的URI是成功的，下一次尝试用最新的成功的身份验证方法对这个URI进行先发制人的身份验证。

> In order to enable http authentication support in Jersey client register the HttpAuthenticationFeature. This feature can provide both authentication methods, digest and basic. Feature can work in the following modes:
> - BASIC: Basic preemptive authentication. In preemptive mode the authentication information is send always with each HTTP request. This mode is more usual than the following non-preemptive mode (if you require BASIC authentication you will probably use this preemptive mode). This mode must be combined with usage of SSL/TLS as the password is send only BASE64 encoded.
> - BASIC NON-PREEMPTIVE:Basic non-preemptive authentication. In non-preemptive mode the authentication information is added only when server refuses the request with 401 status code and then the request is repeated with authentication information. This mode has negative impact on the performance. The advantage is that it does not send credentials when they are not needed. This mode must be combined with usage of SSL/TLS as the password is send only BASE64 encoded.
> - DIGEST: Http digest authentication. Does not require usage of SSL/TLS.
> - UNIVERSAL: Combination of basic and digest authentication. The feature works in non-preemptive mode which means that it sends requests without authentication information. If 401 status code is returned, the request is repeated and an appropriate authentication is used based on the authentication requested in the response (defined in WWW-Authenticate HTTP header. The feature remembers which authentication requests were successful for given URI and next time tries to preemptively authenticate against this URI with latest successful authentication method.

为了初始化该特性，使用静态方法和该特性的构建器。在基本身份验证模式下构建特性的示例:
```
HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic("user", "superSecretPassword");
```
构建基本非抢占模式的特性示例:
```
HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder() .nonPreemptive().credentials("user", "superSecretPassword").build();
```
您还可以在没有任何默认凭证的情况下构建该特性:
```
HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder().build();
```
在这种情况下，您需要为每个请求使用请求属性提供用户名和密码:
```
Response response = client.target("http://localhost:8080/rest/homer/contact").request() .property(HTTP_AUTHENTICATION_BASIC_USERNAME, "homer") .property(HTTP_AUTHENTICATION_BASIC_PASSWORD, "p1swd745").get();
```
这样，您就可以重用同一个客户端来对许多不同的凭证进行身份验证。
更多细节请参见HttpAuthenticationFeature的javadoc。

> To initialize the feature use static methods and builder of this feature. Example of building the feature in Basic authentication mode:
> ```
> HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic("user", "superSecretPassword");
> ```
> Example of building the feature in basic non-preemptive mode:
> ```
> HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder() .nonPreemptive().credentials("user", "superSecretPassword").build();
> ```
> You can also build the feature without any default credentials:
> ```
> HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder().build();
> ```
> In this case you need to supply username and password for each request using request properties:
> ```
> Response response = client.target("http://localhost:8080/rest/homer/contact").request() .property(HTTP_AUTHENTICATION_BASIC_USERNAME, "homer") .property(HTTP_AUTHENTICATION_BASIC_PASSWORD, "p1swd745").get();
> ```
> This allows you to reuse the same client for authenticating with many different credentials.
> See javadoc of the HttpAuthenticationFeature for more details.

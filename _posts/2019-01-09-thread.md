---
layout: post
title:  "多线程"
subtitle: "多线程"
tags: [多线程]
comments: true
---
**使用操作系统管理程序的原因资源利用率，同样多线程使用的原因**

- 资源利用率

- 公平性

- 便利性

---

多线程面对很多问题

安全性（正确性），当多个线程访问某个类时，这个类始终都能表现出正确的行为。
	
无状态的对象一定线程安全。
	
当某个计算的正确性取决于多个线程的交替执行时序时，称为【竞态条件Race Condition】，竞态条件不总是会产生错误，还需要某种不恰当的执行时序。

锁机制【同步代码块Synchronized Block】是Java中用于确保原子性的内置机制。

每个Java对象都可以用synchronized关键字做一个实现同步的锁，这些锁被称为内置锁Intrinsic Lock或者监视器锁Monitor Lock。

线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出，获得内置锁的唯一途径就是进入这个锁保护的同步代码块或方法。

内置锁是可重入的，提升了加锁行为的封装性，简化了面向对象并发代码的开发，比如子类重写父类同步方法并在该方法中调用父类方法，如不可重入，就会导致死锁。

疑问：“重入”意味着获取锁的操作的粒度是“线程”而不是“调用”，这个是什么意思，和POSIX有什么关系？

锁使其保护的代码路径以串行形式来访问，意味着多个线程依次以独占的方式访问对象，而不是并发的访问
一种常见的加锁约定，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

将每个方法都作为同步方法或者持有锁的时间过长都可能导致【活跃性问题Liveness】或【性能问题Performance】
	
**在访问共享的可变状态时需要进行正确的管理**

关键字synchronized可以实现原子性或者确定【临界区Critical Section】

同步还需要一个方面【内存可见性Memory Visibility】

【重排序Reordering】

【最低安全性out-of-thin-air-safety】，适用于绝大多数变量，但是非volatile类型的64位数值变量（double和long）除外。

Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或者写操作分解为两个32位的操作。在不同线程中对这类对象分别进行读操作和写操作，很可能读到某个值的高32位和另一个值的低32位。

在多线程中使用共享且可变的long和double等类型的变量是不安全的，除非用关键字volatile声明或者用锁保护。

声明为volatile类型的变量不会被重排序，不会被缓存在寄存器或者对其他处理器不可见的地方，被读取时总会返回最新写入的值，是一种比synchronized关键字更加轻量级的同步机制。

加锁机制既可以保证原子性又可以保证可见性。

volatile变量通常用做某个操作完成、发生中断或者状态的标志，只可以保证可见性，不保证原子性。

【发布Publish】对象，指的是使对象能够在当前作用域之外的代码中使用，例如将对象的引用保存到一个公有静态变量。

【逸出Escape】，指的是某个不应该发布的对象被发布。

【外部Alien方法】是指行为并不完全由类来规定的方法，包括其他类中定义的方法以及类中可以被改写的方法（既不是私有private方法也不是终结fianl方法）。

封装能够使能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。

**不要在构造过程中使this引用逸出**
当从对象的构造函数中发布对象时（比如，发布一个内部类实例），只是发布了一个尚未构造完成的对象，即使发布对象的语句位于构造函数的最后一行也是如此。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。具体来说，只有在构造函数返回时，this引用才应该从线程中逸出，构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。

【线程封闭Thread Confinement】是实现线程安全性最简单的方法，仅在单线程内访问数据。常见应用就是【JDBC Java Database Connectivity】的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的，不过应用程序服务器提供的连接池是线程安全的，一个线程在从连接池中获取直到归还一个Connection对象之前，这个连接都不会被分配给其他线程。


【Ad-hoc线程封闭】是指，维护线程封闭性的职责完全由程序实现来承担。由于其的脆弱性，尽量少使用。


【栈封闭】，只能通过局部变量才能访问对象。

【ThreadLocal类】，为使用该变量的线程都存着一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。通常用于防止对可变的单实例变量或全局变量进行共享。

**满足同步需求的另一种方法是使用不可变对象Immutable Object**

原子性、可见性、不变性

不可变的对象：对象创建以后其状态就不能修改；对象的所有域都是final类型；对象是正确创建的（在对象的创建期间，this引用没有逸出）。

【事实不可变对象Effectively Immutable Object】，从技术上看来是可变的，但其状态再发布后不会再改变。

在并发程序中使用和共享对象时，可以使用一些实用的策略（Page45）：线程封闭、只读共享、线程安全共享、保护对象。

**设计线程安全的类**

找出构成对象状态的所有变量；找出约束状态变量的不变性条件；建立对象状态的并发访问管理策略。

要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏。

类的不变性（不可变）条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。

可以利用阻塞队列、信号量等同步工具类或者底层机制实现【先验条件Precondition】，创建依赖状态的类。

为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么时线程安全的对象，要么是事实不可变的对象，或者由锁保护的对象。

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。``
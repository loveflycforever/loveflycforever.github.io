---
layout: post
title:  "Retrofit"
date:   2019-06-22
excerpt: "Retrofit"
tags: [Retrofit]
comments: true
---
# Retrofit

Retrofit至少需要Java 7或Android 2.3。

## 什么是Retrofit

适用于Android和Java的类型安全的HTTP客户端，将 HTTP API 转换为 Java 接口，可以向远程 Web 服务器发出同步或异步HTTP请求。

它主要使用注解来描述一个HTTP请求：

支持URL参数和查询参数的动态替换
支持对象转换请求体（例如，JSON，序列化数据结构的协议）
多部分请求正文和文件上传

五个内置注释：GET，POST，PUT，DELETE，和HEAD。资源的相对URL在注释中指定。

Call实例可以同步或异步执行。每个实例只能使用一次，但调用clone()将创建一个可以使用的新实例。

在Android上，回调将在主线程上执行。在JVM上，回调将在执行HTTP请求的同一线程上发生。

### 主流http封装介绍

## Retrofit 特性

OkHttp 的背后是一个叫做 Okio 的库，提供的 IO 支持。

OKio是对于Java原生IO接口的一次封装。

### http2.0

## 使用

目前OKHttp仅支持在https请求下使用HTTP 2.0。

系统间的通讯方式多种多样，例如RPC、WebService、RMI、JMS，作为跨编程语言和跨操作系统平台的远程调用技术，HTTP 请求是最容易想到和实现的方式，简单，通用性高. 不管需要交互的系统具体环境, 只要暴露了 API 接口的系统之间都可以进行交互. 在我们的各个系统间 HTTP 请求也普遍适用。当然它的缺点也很明显，在处理体量巨大的数据时，传输数据会占用超长的连接时间，不仅速度会很慢，而且由于超时或者服务不稳定，以至于断开连接导致调用失败的情况也屡见不鲜。 但是，万幸我们的系统请求的数据一般足够简洁短小，而且网络服务稳定，这个问题忽略。

谈到我们系统目前使用 HTTP请求 方式为调用 Apache HttpClient 这个类库的方法
之前我们使用 HttpClient 请求，方法签名一般
``` java
HttpUtils.request(url, requestType, requestHeaders, requestParameters)
```
亦或者不同的请求方式声明为不同的方法
``` java
HttpUtils.postRequest(url, requestHeaders, requestParameters)
HttpUtils.getRequest(url, requestHeaders, requestParameters)
```

这样做显得很灵活，一个工具类，具体的调用逻辑很明显，只需要资源地址、请求类型、头信息、参数信息就可以调用，但是这种灵活的调用就意味着混乱，随调随用，地址信息配置难以管理，参数信息显示不清晰，返回值类型不明确等等一系列问题

但是作为一个请求调用，这个请求的具体的资源地址，调用方式其实我们并不需要了解，这个完全是请求的一部分属性，而不是我们调用者的重点

同时请求头作为一次请求的一部分，重复的部分我们不需要重复传入，因此我们也没有必要单独作为包装参数去处理它们

补充：
RPC、WebService、RMI、JMS的区别

RPC 简单理解接口调用，好的封装就是doubbo等，不一定使用http作为传输
webservice 跨语言的系统间交互标准，http接口调用传输xml，所以无视平台和语言
RMI 底层http但是只针对java对象，在TCP协议上传递可序列化的java对象，只能用在JVM上，绑定语言
jms 就是所有mq的标准

RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。


XML、JSON、protocol buffer、TLV（三元组编码）、自定义的格式


底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于 传输协议和网络IO来实现，其中传输协议比较出名的有http、tcp、udp等等，http、tcp、udp都是在基于Socket概念上为某类应用场 景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式，所有的分布式应用通讯都基于这个原理而实现，只是为了应用的易用性，各种语言通 常都会提供一些更为贴近应用易用的应用层协议。

# Retrofit

Retrofit至少需要Java 7或Android 2.3。

## 什么是Retrofit

适用于Android和Java的类型安全的HTTP客户端，主要使用注解来描述一个 HTTP 请求，将 HTTP API 转换为 Java 接口形式，并且可以向远程 Web 服务器发出同步或异步 HTTP 请求。

- 支持URL参数和查询参数的动态替换
- 支持对象转换为请求体（例如，JSON，各种序列化数据结构的协议）
- 支持表单和文件上传


底层使用的是 OKHttp 做网络请求，可以理解为 Retrofit 仅负责网络请求接口的封装。


### 主流http封装介绍

HttpURLConnection 是 Java 的标准类，什么都没封装，用起来太原始，不方便，比如重访问的自定义，以及一些高级功能等。

HttpClient 就是一个增强版的 HttpURLConnection，它只是关注于如何发送请求、接收响应，以及管理HTTP连接。

Volley，它的设计目标就是适合去进行数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。

## OkHttp 特性

OkHttp 是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 Http 请求库。

- 支持 HTTP2.0 允许对同一主机的所有请求共享 socket。
- 连接池减少了请求延迟（如果是 HTTP2.0 则不可用）。
- GZIP 缩小下载大小。
- 响应缓存可以完全避免网络重复请求。

它的请求/响应API采用流畅的构建器和不变性设计。它支持同步阻塞调用和带回调的异步调用。

## OkIO 特性

OkHttp 的背后是一个叫做 Okio 的库，提供的 IO 支持。

OkIO是对于Java原生IO接口的一次封装。

Okio中特有的两个类Source，Sink代表的就是传统的输入流，和输出流。

Okio类相当于一个简单工厂，对外暴露接口，可以产生各式各样的Sink和Source。

Buffer的存储容器用的不是数组，而是Segment类对象构成的循环链表，Segment用了享元模式，有SegmentPool对Segment进行管理。

定时模块主要由Timeout和其子类AnsycTimeout类组成。

缓存是Okio中最重要的部分，缓存模块主要由Buffer，Segment，SegmentPool这三个类构成，Buffer内实际存储数据的容器是一条由Segment构成的的循环链表。暂时不用的Segment由SegmentPool通过单链表保存，防止频繁GC，避免内存抖动，增加资源的重复利用，提高效率。

对比Java IO和Okio我们可以看出OKio使用更方便，支持链式调用，代码简洁、优美。不需要把各种装饰类读写操作。数据容器采用循环链表实现，Segment通过分裂、合并、共享等操作避免了拷贝操作。SegmentPool会对暂时不用的Segment回收保存，避免频繁GC。支持阻塞IO和非阻塞IO，提供了一系列的方便工具，如GZip的透明处理，对数据计算md5、sha1等都提供了支持，对数据校验非常方便。

### http2.0

略

## 使用

目前OKHttp仅支持在https请求下使用HTTP 2.0。

五个内置的请求方法的注释：GET、POST、PUT、DELETE和HEAD。资源的相对 URL 可以在注释中指定。

@Headers，添加请求头
@Path，替换路径
@Query，替代参数值，通常是结合get请求的
@FormUrlEncoded，用表单数据提交
@Field，替换参数值，是结合post请求的

Call实例可以同步或异步执行。每个实例只能使用一次，但调用clone()将创建一个可以使用的新实例。在JVM上，回调将在执行HTTP请求的同一线程上发生。

略


对`java.io`、`java.nio`的一个补充，更简单去访问、存储和处理你的数据

最初是作 HTTP客户端OkHttp的一个组件 。


Okio围绕两种类型构建，它们将大量功能集成到一个简单的API中：

`ByteString`是一个不可变的字节序列。可以很容易地将二进制数据变为一个值，它知道如何编码和解码为hex，base64和UTF-8。

`Buffer`是一个可变的字节序列。将数据写入末尾并从前面读取。不需要管理positions, limits, 或者 capacities.

ByteString 和 Buffer做了一些事情来节省CPU和内存。




如果将UTF-8字符串编码为一个ByteString，它会缓存对该字符串的引用，这样如果以后对其进行解码，则无需执行任何操作。

Buffer实现为分段的链表。将数据从一个缓冲区移动到另一个缓冲区时，它会重新分配段的所有权，而不是复制数据。这种方法对多线程程序特别有用：与网络通信的线程可以与工作线程交换数据而无需任何复制或仪式。

BufferSource分段读取socket的内容


- Base URL: 总是以 /结尾

- @Url: 不要以 / 开头

在Retrofit 2.0中，不管 response 是否能被解析。onResponse总是会被调用。

Buffer，Segment,SegmentPool

数据是通过Buffer写入一个叫Segment容器中的

SegmentPool,其实它的存在很简单，保存暂时不用的数据容器，防止频繁GC，基本上所有的XX池的作用的是这样，防止已申请的资源被回收，增加资源的重复利用，提高效率，减少GC,避免内存抖动



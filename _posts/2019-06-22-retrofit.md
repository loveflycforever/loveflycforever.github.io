---
layout: post
title:  "从 Retrofit 的应用谈开了去"
subtitle: "适用于 Android 和 Java 的类型安全的 HTTP 客户端"
bigimg: https://www.patek.com/resources/img/home/pp-ladies-dotcom-GARDEN-teaser_1600.jpg
tags: [Java, HTTP Client, Retrofit]
comments: true
---
> Retrofit 至少需要 Java 7 或 Android 2.3。

# 一、基本

### 1.1 什么是 Retrofit

根据 [Retrofit 官方文档](https://square.github.io/retrofit/) 页面简述
“A type-safe HTTP client for Android and Java”，
可以了解到 Retrofit 是“一个适用于 Android 和 Java 的类型安全的 HTTP 客户端”。

在功能上，它可以将 HTTP API 以 Java 接口的方式定义，向远程Web服务器发出同步或异步 HTTP 请求。

下面是一个简单的示例

``` java
/**
 * Created by JSF on 2020/6/1.
 */
public interface GitHubService {

    /**
     * 定义的 HTTP API
     */
    @GET("users/{user}/repos")
    Call<List<Repo>> listRepos(@Path("user") String user);

    public static void main(String[] args) {
        // 构建实例
        Retrofit retrofit = new Retrofit.Builder().baseUrl("https://api.github.com/").build();

        // 创建服务
        GitHubService service = retrofit.create(GitHubService.class);

        // 调用请求
        Call<List<Repo>> repos = service.listRepos("octocat");
    }

}
```

通过这个例子看到，Retrofit 使用注解来描述 HTTP 请求，将 API 接口转换为可调用对象。

它可以动态地替换 URL 的参数，支持查询参数，
可以将对象转换为请求体（例如，JSON，protocol buffers），
可以使用 Multipart 类型的请求体，支持文件上传。

而且，调用返回的 Call 实例可以同步或异步执行（每个实例只能使用一次，但调用`clone()`将创建一个可以使用的新实例）。
在 Android 环境中，回调将在主线程上执行，在 JVM 环境中，回调将在执行 HTTP 请求的同一线程上发生。

> Protocol Buffers (a.k.a., protobuf) 是 Google 开发的用于序列化结构化数据的一种语言无关，平台无关的可扩展机制。

### 1.2 Retrofit 有哪些内容

#### 1.2.1 注解

注解是 Retrofit 的主要使用的部分，按照分类，
首先，是 5 种请求方式注解，`@GET`、`@POST`、`@PUT`、`@DELETE`和`@HEAD`。在这些注释中指定资源的相对 URL 。

``` java
@GET("users/list?sort=desc")
```

> 绝对地址和相对地址的区别：
“/users/132/repos”是绝对地址，地址前的“/”指向根目录，所以它是相对于__根目录__的地址，
"users/132/repos"是相对地址，即相对__当前目录__的地址。

接着，是 3 种 URL 操作注解，
`@Path`用于方法参数来动态替换 URL 的地址块，
`@Query`定义查询参数，
`@QueryMap`使用 Map 定义复杂的查询参数。

``` java
@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId, @Query("sort") String sort);

@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId, @QueryMap Map<String, String> options);
```

然后，是指定请求体（Request Body）的注解`@Body`。可以定义一个对象作为请求体。不过，需要指定转换器用来转换对象，除此之外，可以使用类库提供的 RequestBody 类。

``` java
@POST("users/new")
Call<User> createUser(@Body User user);
```

然后，是提交表单所需要的注解，`@FormUrlEncoded`、`@Field`、`@FieldMap`。

``` java
@FormUrlEncoded
@POST("user/edit")
Call<User> updateUser(@Field("first_name") String first, @Field("last_name") String last);
```

如果是 Multipart 类型的表单请求，还会用到`@Multipart`、`@Part`、`@PartMap`。

``` java
@Multipart
@PUT("user/photo")
Call<User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);
```

最后，是请求头相关的注解`@Headers`、`@Header`、`@HeaderMap`。
注意，请求头不会相互覆盖，所有具有相同名称的请求头都将被包含在请求中。

``` java
@Headers({
    "Accept: application/vnd.github.v3.full+json",
    "User-Agent: Retrofit-Sample-App"
})
@GET("users/name")
Call<User> getUser(@Header("Authorization") String authorization);

@Headers({
    "Accept: application/vnd.github.v3.full+json",
    "User-Agent: Retrofit-Sample-App"
})
@GET("users/name")
Call<User> getUser(@HeaderMap Map<String, String> headers);
```

#### 1.2.2 配置

Retrofit 提供合理的默认设置，同时也允许自定义配置。以下，主要说明的就是转换器（Converters）。

默认情况下，Retrofit 只能将响应体反序列化为 OkHttp 类库的 ResponseBody 类型，
并且`@Body`注解只能接受 RequestBody 类型。
但是，可以通过添加转换器的方式来支持其他类型。

Retrofit 依据 6 种流行的序列化库模块，提供了对应的转换器模块：

- Gson: com.squareup.retrofit2:converter-gson

- Jackson: com.squareup.retrofit2:converter-jackson

- Moshi: com.squareup.retrofit2:converter-moshi

- Protobuf: com.squareup.retrofit2:converter-protobuf

- Wire: com.squareup.retrofit2:converter-wire

- Simple XML: com.squareup.retrofit2:converter-simplexml

- Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars

``` java
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com")
    .addConverterFactory(GsonConverterFactory.create())
    .build();
```

当然，如果需要使用现有的 Retrofit 转换器模块不支持的格式，可以通过创建继承`Converter.Factory`类的类，并在构建适配器时传入实例，可以轻松创建属于自己的转换器模块。

> [Retrofit Javadoc](https://square.github.io/retrofit/2.x/retrofit/)

### 1.3 为什么要使用 Retrofit

此时，再回看关于 Retrofit 的简述，其中显而易见的关键字为`类型安全`、`HTTP 客户端`。

#### 1.3.1 HTTP 客户端

先说说 HTTP 客户端，为什么使用它？
HTTP 协议是最重要的网络协议之一，
目前各种移动端的开发、Java Web 前后端分离架构，
越来越多的 Java 应用使用 HTTP 协议访问资源。
常说的 HTTP 客户端就是一种基于 HTTP 协议的网络请求封装框架。

当前主流网络请求封装框架介绍

- Volley

Google 推出的异步网络请求框架和图片加载框架。适合数据量小，通信频繁的网络操作。
但是，不适用于数据量比较大的操作，比如 POST 大数据或者下载。

- android-async-http

基于 Apache 的 HttpClient 库构建的基于异步回调的 HTTP 客户端。
所有请求都是在应用程序的主 UI 线程之外发出的，
但任何回调逻辑都将在使用 Android 的 Handler 消息传递创建回调的同一线程上执行。

- ion

基于 AndroidAsync 的 HTTP 请求库。

- AndroidAsync

使用了 NIO 的方式实现的低级网络协议库。

- HttpURLConnection

Java 的标准类，通过的 java.net 包提供 HTTP 访问资源的基本功能。

- HttpClient

Apache 提供的库，用于传输和接收 HTTP 消息。

- RestTemplate

Spring 提供的用于访问 Rest 服务的客户端。

- OkHttp

Square 提供的支持同步阻塞调用和带回调的异步调用执行 HTTP 的库。

系统间的通讯方式多种多样，例如RPC、WebService、RMI、JMS，作为跨编程语言和跨操作系统平台的远程调用技术，
HTTP 请求是最容易想到和实现的方式，简单，通用性高. 不管需要交互的系统具体环境, 只要暴露了 API 接口的系统之间都可以进行交互。
当然它的缺点也很明显，在处理体量巨大的数据时，传输数据会占用超长的连接时间，不仅速度会很慢，
而且由于超时或者服务不稳定，以至于断开连接导致调用失败的情况也屡见不鲜。

目前系统使用 HTTP 请求方式为使用 Apache HttpClient 这个类库，并简单包装的工具类方法。

方法签名一般如下：

``` java
HttpUtils.request(url, requestType, requestHeaders, requestParameters)
```

亦或者是将不同的请求方式声明为不同的方法：

``` java
HttpUtils.postRequest(url, requestHeaders, requestParameters)
HttpUtils.getRequest(url, requestHeaders, requestParameters)
```

这样似乎很灵活，具体的调用逻辑很明显，只需要资源地址、请求类型、请求头信息、各项参数信息就可以调用，
但是这种灵活的调用也显着混乱，譬如，具体的地址信息难以统一管理配置，各项请求头、请求参数信息显示不清晰，请求的返回值类型不明确等等一系列问题

更进一步来说，作为一个方法调用，这个方法内部的请求的具体的资源地址，调用方式其实我们并不需要了解，
+这个完全是作为请求的属性，而不是我们调用者的重点。

#### 1.3.2 类型安全

每个对象在定义时被分配一个类型。
对于一个程序或者程序的一部分，如果使用的对象符合它们规定的类型，那么它们是类型安全的。

### 1.4 Retrofit 到底是什么

底层默认使用的是 OkHttp 做网络请求，可以理解为 Retrofit 仅负责网络请求接口的封装。

它的请求/响应 API 采用流畅的构建器和不变性设计。它支持同步阻塞调用和带回调的异步调用。

OkHttp 的背后是一个叫做 Okio 的库提供的 IO 支持，Okio是对于Java原生IO接口的一次封装。


# 二、 关联

## 2.1 跨节点通信

在传统的 Java 应用中，通常使用以下 4 种方式进行跨节点通信。

1．通过 RMI 进行远程服务调用。

2．通过 Java 的 Socket + Java 序列化的方式进行跨节点调用。

3．利用一些开源的 RPC 框架进行远程服务调用，例如 Facebook 的 Thrift，Google 的 gRPC 等。

4．利用标准的公有协议进行跨节点服务调用，例如 HTTP + XML、Restful + JSON 或者 WebService。

当前比较流行的序列化方式可以分为两大类:

1．文本类序列化方式：主要包括 JSON 和 XML，它们的优点是：支持跨语言、可读性好、配套的支持工具比较全。缺点就是：序列化之后的码流比较大、冗余内容多，性能相对比较差。

2．私有的二进制类序列化方式：比较流行的有 Thrift 序列化框架、MessagePack 和谷歌的 Protobuf 框架。它的优点是性能高，缺点就是可读性差，支撑的工具链不健全。

- RPC 、 WebService 、 RMI 、 JMS 的区别

RPC ，远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
简单来说就是一种编程模型，目的是解决分布式系统中服务之间的调用问题，使得远程调用和本地调用一样方便。
具体的实现，比如，Dubbo，它作为一个高性能高可靠的 RPC 框架，使用了 Zookeeper 作为注册中心，提供了多种负载均衡策略，还涉及到缓存、异步、线程等内容。

WebService 跨语言的系统间交互标准， HTTP 接口调用传输 XML ，所以无视平台和语言。

RMI ，Java 实现的一种远程过程调用的协议。底层 HTTP 但是只针对 Java 对象，在 TCP 协议上传递可序列化的 Java 对象，只能用在 JVM 上，绑定语言。

JMS ，Java 消息服务，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。
Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。

- RPC 框架与 HTTP 的区别

RPC 框架的优势首先就是长链接，不必每次通信都要像 HTTP 一样去3次握手，减少了网络开销；
其次就是RPC框架一般都有注册中心，有丰富的监控管理；
再者发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。

- 网络通信中数据传输序列化的方式

XML、JSON、protocol buffer、TLV（三元组编码）、自定义的格式

底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现。
其中传输协议比较出名的有 http、tcp、udp 等等。
http、tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议。
网络IO，主要有bio、nio、aio三种方式。
所有的分布式应用通讯都基于这个原理而实现，只是为了应用的易用性，各种语言通常都会提供一些更为贴近应用易用的应用层协议。

## 2.2 OkHttp 特性

OkHttp`3.12.x`分支支持Android`2.3+`（API级别9+）和Java`7`+。这些平台不支持TLS 1.2，不应使用。

OkHttp 适用于 Android 5.0+（API级别21+）和 Java 8+。

- HTTP / 2支持允许对同一主机的所有请求共享套接字。
- 连接池减少了请求延迟（如果HTTP/2不可用）。
- 透明的 GZIP 缩小了下载大小。
- 响应缓存可以完全避免网络重复请求。

> 目前 OkHttp 仅支持在 https 请求下使用 HTTP 2.0。


OkHttp 依赖于 Okio 库，一个微小并且高性能的 I/O 库。


# 三、 拓展

## 3.1 HTTP

超文本传输协议，Hypertext Transfer Protocol。
一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。
默认端口号80，
### 3.1.1 报文

请求报文的4个组成部分：请求行、请求头部、空行和请求数据。

| **HTTP 请求报文的一般格式** | **** | **** | **** | **** | **** | **** | **** |
|---|---|---|---|---|---|---|---|
| 请求方法 | (空格) | URL | (空格) | 协议版本 | (回车符)(换行符) |  | 请求行 |
| 头部字段名1 | : | 头部字段值1 | (回车符)(换行符) |  |  |  |  |
| ......(此处省略 头部字段2 至 头部字段n) |  |  |  |  |  |  | 请求头部 |
| 头部字段名n | : | 头部字段值n | (回车符)(换行符) |  |  |  |  |
| (回车符)(换行符) |  |  |  |  |  |  | 空行 |
| 请求数据 |  |  |  |  |  |  | 请求数据 |

响应报文的4个组成部分：状态行、消息报头、空行和响应正文。

| **HTTP 响应报文的一般格式** | **** | **** | **** | **** | **** | **** | **** |
|---|---|---|---|---|---|---|---|
| 协议版本 | (空格) | 状态码 | (空格) | 原因短语 | (回车符)(换行符) |  | 状态行 |
| 头部字段名 | : | 头部字段值 | (回车符)(换行符) |  |  |  |  |
| ......(此处省略 头部字段2 至 头部字段n) |  |  |  |  |  |  | 消息报头 |
| 头部字段名 | : | 头部字段值 | (回车符)(换行符) |  |  |  |  |
| (回车符)(换行符) |  |  |  |  |  |  | 空行 |
| 响应数据 |  |  |  |  |  |  | 响应正文 |

#### 3.1.1.1 请求方法的介绍
             
HTTP 协议中共定义了9种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，具体介绍如下：

`GET`	    请求指定的页面信息，并返回实体主体。
`HEAD`	    类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。
`POST`	    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
`PUT`	    从客户端向服务器传送的数据取代指定的文档的内容。
`DELETE`    请求服务器删除指定的资源。
`CONNECT`   HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
`OPTIONS`   允许客户端查看服务器的性能。
`TRACE`	    回显服务器收到的请求，主要用于测试或诊断。
`PATCH`	    是对 PUT 方法的补充，用来对已知资源进行局部更新 。

虽然 HTTP 的请求方式有9种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。

#### 3.1.1.2 响应头信息

Allow	
服务器支持哪些请求方法（如GET、POST等）。

Content-Encoding	
文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept-Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。

Content-Length	
表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。

Content-Type	
表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。

Date	
当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。

Expires	
应该在什么时候认为文档已经过期，从而不再缓存它？

Last-Modified	
文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。

Location	
表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。

Refresh	
表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。
注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。

注意Refresh的意义是"N秒之后刷新本页面或访问指定页面"，而不是"每隔N秒刷新本页面或访问指定页面"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV="Refresh" ...＞。

注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。

Server	
服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。

Set-Cookie	
设置和页面关联的Cookie。Servlet不应使用response.setHeader("Set-Cookie", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。

WWW-Authenticate	
客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader("WWW-Authenticate", "BASIC realm=＼"executives＼"")。
注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。

#### 3.1.1.3 媒体类型

Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。

Content-Type 标头告诉客户端实际返回的内容的内容类型。

常见的媒体格式类型如下：

text/html ： HTML格式
text/plain ：纯文本格式
text/xml ： XML格式
image/gif ：gif图片格式
image/jpeg ：jpg图片格式
image/png：png图片格式
以application开头的媒体格式类型：

application/xhtml+xml ：XHTML格式
application/xml： XML数据格式
application/atom+xml ：Atom XML聚合格式
application/json： JSON数据格式
application/pdf：pdf格式
application/msword ： Word文档格式
application/octet-stream ： 二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）
另外一种常见的媒体格式是上传文件之时使用的：

multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

#### 3.1.1.4 状态码分类

1**	信息，服务器收到请求，需要请求者继续执行操作
2**	成功，操作被成功接收并处理
3**	重定向，需要进一步的操作以完成请求
4**	客户端错误，请求包含语法错误或无法完成请求
5**	服务器错误，服务器在处理请求的过程中发生了错误

400	Bad Request	客户端请求的语法错误，服务器无法理解
401	Unauthorized	请求要求用户的身份认证
402	Payment Required	保留，将来使用
403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
405	Method Not Allowed	客户端请求中的方法被禁止
406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求
407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
408	Request Time-out	服务器等待客户端发送的请求时间过长，超时
409	Conflict	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突
410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息
412	Precondition Failed	客户端请求信息的先决条件错误
413	Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息
414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理
415	Unsupported Media Type	服务器无法处理请求附带的媒体格式
416	Requested range not satisfiable	客户端请求的范围无效
417	Expectation Failed	服务器无法满足Expect的请求头信息
500	Internal Server Error	服务器内部错误，无法完成请求
501	Not Implemented	服务器不支持请求的功能，无法完成请求
502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求
505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理



### 3.1.2 为什么是HTTP

HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。

HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

HTTP 最重要也是最突出的优点是__简单、灵活、易于扩展__。

简单：它的主要组成就是 header + body，头部信息也是简单的文本格式，而且 HTTP 的请求报文根据英文也能猜出来个大概的意思，降低学习门槛，能够让更多的人研究和开发 HTTP 应用。

HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被制定死，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由。

基于以上优点，因此 HTTP 应用广泛、环境成熟。

因为 HTTP 协议本身不属于一种语言，它并不限定某种编程语言或者操作系统，所以天然具有跨语言、跨平台的优越性。
而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具。

随着移动互联网的发展， HTTP 的触角已经延伸到了世界的每一个角落，从简单的 Web 页面到复杂的 JSON、XML 数据，
从台式机上的浏览器到手机上的各种 APP、新闻、论坛、购物、手机游戏，很难找到一个没有使用 HTTP 的地方。

无状态
无状态其实既是优点又是缺点。
因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息。
不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
既然服务器没有记忆能力，它就无法支持需要连续多个步骤的事务操作。
每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。由此出现了 Cookie 技术。

明文
HTTP 协议里还有一把优缺点一体的双刃剑，就是明文传输。
明文意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。
对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利。
当然缺点也是显而易见的，就是不安全，可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被更改过。

性能
HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。

### 3.1.2 HTTP 2.0
报文结构、请求方法、URI、头字段、
应答模式、连接管理

这里的小标题是__HTTP 2.0__，我们谈谈 HTTP 的版本进化之路

HTTP0.9、HTTP1.0、HTTP1.1、HTTP2

### 3.1.3 HTTPS

由于 HTTP 天生明文传输的特性，在 HTTP 的传输过程中，任何人都有可能从中截获、修改或者伪造请求发送，所以可以认为 HTTP 是不安全的；
在 HTTP 的传输过程中不会验证通信方的身份，因此 HTTP 信息交换的双方可能会遭到伪装，也就是没有用户验证；
在 HTTP 的传输过程中，接收方和发送方并不会验证报文的完整性

HTTPS 的全称是 Hypertext Transfer Protocol Secure，
是一个在计算机世界里专门在两点之间安全的传输文字、图片、音频、视频等超文本数据的约定和规范。 
HTTPS 是 HTTP 协议的一种扩展，它本身并不保传输的证安全性

在 HTTPS 中，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。


加密(Encryption)， HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息。
数据一致性(Data integrity)，数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么。
身份认证(Authentication)，是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。

默认端口号443，

TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本，它们是用于在互联网两台计算机之间用于身份验证和加密的一种协议。

SSL/TLS 通过将称为 X.509 证书的数字文档将网站和公司的实体信息绑定到加密密钥来进行工作。
每一个密钥对(key pairs) 都有一个 私有密钥(private key) 和 公有密钥(public key)，
私有密钥是独有的，一般位于服务器上，用于解密由公共密钥加密过的信息；
公有密钥是公有的，与服务器进行交互的每个人都可以持有公有密钥，
用公钥加密的信息只能由私有密钥来解密。

> X.509 是公开密钥证书的标准格式，这个文档将加密密钥与（个人或组织）进行安全的关联。

## 3.2 TCP

HTTP 使用 TCP/IP 作为通信协议，这是因为 TCP 是一种可靠的协议，而可靠能保证数据不丢失。


TCP 协议，Transmission Control Protocol ，传输控制协议。






## 3.3 Okio 特性

OkHttp 的背后是一个叫做 Okio 的库，提供的 IO 支持。

OkIO是对于Java原生IO接口的一次封装。

Okio中特有的两个类Source，Sink代表的就是传统的输入流，和输出流。

Okio类相当于一个简单工厂，对外暴露接口，可以产生各式各样的Sink和Source。

Buffer的存储容器用的不是数组，而是Segment类对象构成的循环链表，Segment用了享元模式，有SegmentPool对Segment进行管理。

定时模块主要由Timeout和其子类AnsycTimeout类组成。

缓存是Okio中最重要的部分，缓存模块主要由Buffer，Segment，SegmentPool这三个类构成，Buffer内实际存储数据的容器是一条由Segment构成的的循环链表。暂时不用的Segment由SegmentPool通过单链表保存，防止频繁GC，避免内存抖动，增加资源的重复利用，提高效率。

对比Java IO和Okio我们可以看出OKio使用更方便，支持链式调用，代码简洁、优美。不需要把各种装饰类读写操作。数据容器采用循环链表实现，Segment通过分裂、合并、共享等操作避免了拷贝操作。SegmentPool会对暂时不用的Segment回收保存，避免频繁GC。支持阻塞IO和非阻塞IO，提供了一系列的方便工具，如GZip的透明处理，对数据计算md5、sha1等都提供了支持，对数据校验非常方便。

对`java.io`、`java.nio`的一个补充，更简单去访问、存储和处理你的数据

最初是作 HTTP客户端OkHttp的一个组件 。

Okio围绕两种类型构建，它们将大量功能集成到一个简单的API中：

`ByteString`是一个不可变的字节序列。可以很容易地将二进制数据变为一个值，它知道如何编码和解码为hex，base64和UTF-8。

`Buffer`是一个可变的字节序列。将数据写入末尾并从前面读取。不需要管理positions, limits, 或者 capacities.

ByteString 和 Buffer做了一些事情来节省CPU和内存。

如果将UTF-8字符串编码为一个ByteString，它会缓存对该字符串的引用，这样如果以后对其进行解码，则无需执行任何操作。

Buffer实现为分段的链表。将数据从一个缓冲区移动到另一个缓冲区时，它会重新分配段的所有权，而不是复制数据。这种方法对多线程程序特别有用：与网络通信的线程可以与工作线程交换数据而无需任何复制或仪式。

BufferSource分段读取socket的内容






- Base URL: 总是以 /结尾

- @Url:   不要以 / 开头

在Retrofit 2.0中，不管 response 是否能被解析。onResponse总是会被调用。

Buffer，Segment,SegmentPool

数据是通过Buffer写入一个叫Segment容器中的

SegmentPool,其实它的存在很简单，保存暂时不用的数据容器，防止频繁GC，基本上所有的XX池的作用的是这样，防止已申请的资源被回收，增加资源的重复利用，提高效率，减少GC,避免内存抖动




## 3.3 JAVA泛型与类型安全


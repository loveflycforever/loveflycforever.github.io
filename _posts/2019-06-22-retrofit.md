---
layout: post
title:  "从 Retrofit 的应用谈开了去"
subtitle: "适用于 Android 和 Java 的类型安全的 HTTP 客户端"
bigimg: https://www.patek.com/resources/img/home/pp-ladies-dotcom-GARDEN-teaser_1600.jpg
tags: [Java, HTTP Client, Retrofit]
comments: true
---
> Retrofit 至少需要 Java 7 或 Android 2.3。

# 一、基础

## 1.1 了解

### 1.1.1 什么是 Retrofit

根据 [Retrofit 官方文档](https://square.github.io/retrofit/) 页面简述，
为 “A type-safe HTTP client for Android and Java”，
一个适用于 Android 和 Java 的类型安全的 HTTP 客户端。
它可以将 HTTP API 以 Java 接口的方式定义，向远程Web服务器发出同步或异步 HTTP 请求。

``` java
/**
 * Created by JSF on 2020/6/1.
 */
public interface GitHubService {

    @GET("users/{user}/repos")
    Call<List<Repo>> listRepos(@Path("user") String user);

    public static void main(String[] args) {
        // 构造 Retrofit
        Retrofit retrofit = new Retrofit.Builder()
            .baseUrl("https://api.github.com/")
            .build();

        // 创建服务
        GitHubService service = retrofit.create(GitHubService.class);

        // 调用请求
        Call<List<Repo>> repos = service.listRepos("octocat");
    }

}
```

通过这个简单的例子看到，Retrofit 使用注解来描述 HTTP 请求，将 API 接口转换为可调用对象的类。
它可以动态地替换 URL 参数的，支持查询参数，
可以将对象转换为请求体（例如，JSON，protocol buffers），
可以使用 Multipart 类型的请求体，支持文件上传。

而且，调用返回的 Call 实例可以同步或异步执行（每个实例只能使用一次，但调用`clone()`将创建一个可以使用的新实例）。
在 Android 环境中，回调将在主线程上执行，
在 JVM 环境中，回调将在执行 HTTP 请求的同一线程上发生。

> Protocol Buffers (a.k.a., protobuf) 是 Google 开发的用于序列化结构化数据的一种语言无关，平台无关的可扩展机制。

### 1.1.2 Retrofit 有哪些内容

#### 1.1.2.1 注解

注解是 Retrofit 的主要使用的部分，按照分类，
首先，是 5 种请求方式注解，`@GET`、`@POST`、`@PUT`、`@DELETE`和`@HEAD`。在这些注释中指定资源的相对 URL 。

``` java
@GET("users/list?sort=desc")
```

> 绝对地址和相对地址的区别：
“/users/132/repos”是绝对地址，地址前的“/”指向根目录，所以它是相对于__根目录__的地址，
"users/132/repos"是相对地址，即相对__当前目录__的地址。

接着，是 3 种 URL 操作注解，
`@Path`用于方法参数来动态替换 URL 的地址块，
`@Query`定义查询参数，
`@QueryMap`使用 Map 定义复杂的查询参数。

``` java
@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId, @Query("sort") String sort);

@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId, @QueryMap Map<String, String> options);
```

然后，是指定请求体（Request Body）的注解`@Body`。可以定义一个对象作为请求体。不过，需要指定转换器用来转换对象，除此之外，可以使用类库提供的 RequestBody 类。

``` java
@POST("users/new")
Call<User> createUser(@Body User user);
```

然后，是提交表单所需要的注解，`@FormUrlEncoded`、`@Field`、`@FieldMap`。

``` java
@FormUrlEncoded
@POST("user/edit")
Call<User> updateUser(@Field("first_name") String first, @Field("last_name") String last);
```

如果是 Multipart 类型的表单请求，还会用到`@Multipart`、`@Part`、`@PartMap`。

``` java
@Multipart
@PUT("user/photo")
Call<User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);
```

最后，是请求头相关的注解`@Headers`、`@Header`、`@HeaderMap`。
注意，请求头不会相互覆盖，所有具有相同名称的请求头都将被包含在请求中。

``` java
@Headers({
    "Accept: application/vnd.github.v3.full+json",
    "User-Agent: Retrofit-Sample-App"
})
@GET("users/name")
Call<User> getUser(@Header("Authorization") String authorization);

@Headers({
    "Accept: application/vnd.github.v3.full+json",
    "User-Agent: Retrofit-Sample-App"
})
@GET("users/name")
Call<User> getUser(@HeaderMap Map<String, String> headers);
```

#### 1.1.2.2 配置

Retrofit 提供合理的默认设置，同时也允许自定义配置。以下，主要说明的就是转换器（Converters）。

默认情况下，Retrofit 只能将响应体反序列化为 OkHttp 类库的 ResponseBody 类型，
并且`@Body`注解只能接受 RequestBody 类型。
但是，可以通过添加转换器的方式来支持其他类型。

Retrofit 依据 6 种流行的序列化库模块，提供了对应的转换器模块：

- Gson: com.squareup.retrofit2:converter-gson

- Jackson: com.squareup.retrofit2:converter-jackson

- Moshi: com.squareup.retrofit2:converter-moshi

- Protobuf: com.squareup.retrofit2:converter-protobuf

- Wire: com.squareup.retrofit2:converter-wire

- Simple XML: com.squareup.retrofit2:converter-simplexml

- Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars

``` java
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com")
    .addConverterFactory(GsonConverterFactory.create())
    .build();
```

当然，如果需要使用现有的 Retrofit 转换器模块不支持的格式，可以通过创建继承`Converter.Factory`类的类，并在构建适配器时传入实例，可以轻松创建属于自己的转换器模块。

> [Retrofit Javadoc](https://square.github.io/retrofit/2.x/retrofit/)

### 1.1.3 为什么要使用 Retrofit

此时，再回看关于 Retrofit 的简述，其中显而易见的关键字为`类型安全`、`HTTP 客户端`。

#### 1.1.3.1 HTTP 客户端

先说说 HTTP 客户端，为什么使用它？
HTTP 协议是最重要的网络协议之一，
目前各种移动端的开发、Java Web 前后端分离架构，
越来越多的 Java 应用使用 HTTP 协议访问资源。
常说的 HTTP 客户端就是一种基于 HTTP 协议的网络请求封装框架。

当前主流网络请求封装框架介绍

- Volley

Google 推出的异步网络请求框架和图片加载框架。适合数据量小，通信频繁的网络操作。
但是，不适用于数据量比较大的操作，比如 POST 大数据或者下载。

- android-async-http

基于 Apache 的 HttpClient 库构建的基于异步回调的 HTTP 客户端。
所有请求都是在应用程序的主 UI 线程之外发出的，
但任何回调逻辑都将在使用 Android 的 Handler 消息传递创建回调的同一线程上执行。

- ion

基于 AndroidAsync 的 HTTP 请求库。

- AndroidAsync

使用了 NIO 的方式实现的低级网络协议库。

- HttpURLConnection

Java 的标准类，通过的 java.net 包提供 HTTP 访问资源的基本功能。

- HttpClient

Apache 提供的库，用于传输和接收 HTTP 消息。

- RestTemplate

Spring 提供的用于访问 Rest 服务的客户端。

- OkHttp

Square 提供的支持同步阻塞调用和带回调的异步调用执行 HTTP 的库。

系统间的通讯方式多种多样，例如RPC、WebService、RMI、JMS，作为跨编程语言和跨操作系统平台的远程调用技术，
HTTP 请求是最容易想到和实现的方式，简单，通用性高. 不管需要交互的系统具体环境, 只要暴露了 API 接口的系统之间都可以进行交互。
当然它的缺点也很明显，在处理体量巨大的数据时，传输数据会占用超长的连接时间，不仅速度会很慢，
而且由于超时或者服务不稳定，以至于断开连接导致调用失败的情况也屡见不鲜。

目前系统使用 HTTP 请求方式为使用 Apache HttpClient 这个类库，并简单包装的工具类方法。

方法签名一般如下：

``` java
HttpUtils.request(url, requestType, requestHeaders, requestParameters)
```

亦或者是将不同的请求方式声明为不同的方法：

``` java
HttpUtils.postRequest(url, requestHeaders, requestParameters)
HttpUtils.getRequest(url, requestHeaders, requestParameters)
```

这样似乎很灵活，具体的调用逻辑很明显，只需要资源地址、请求类型、请求头信息、各项参数信息就可以调用，
但是这种灵活的调用也显着混乱，譬如，具体的地址信息难以统一管理配置，各项请求头、请求参数信息显示不清晰，请求的返回值类型不明确等等一系列问题

更进一步来说，作为一个方法调用，这个方法内部的请求的具体的资源地址，调用方式其实我们并不需要了解，
+这个完全是作为请求的属性，而不是我们调用者的重点。

#### 1.1.3.1 类型安全

每个对象在定义时被分配一个类型。
对于一个程序或者程序的一部分，如果使用的对象符合它们规定的类型，那么它们是类型安全的。

### 1.1.4 Retrofit 到底是什么

底层默认使用的是 OkHttp 做网络请求，可以理解为 Retrofit 仅负责网络请求接口的封装。

它的请求/响应 API 采用流畅的构建器和不变性设计。它支持同步阻塞调用和带回调的异步调用。

OkHttp 的背后是一个叫做 Okio 的库提供的 IO 支持，Okio是对于Java原生IO接口的一次封装。


# 二、 关联

## 2.1 跨节点通信

在传统的 Java 应用中，通常使用以下 4 种方式进行跨节点通信。

1．通过 RMI 进行远程服务调用。

2．通过 Java 的 Socket + Java 序列化的方式进行跨节点调用。

3．利用一些开源的 RPC 框架进行远程服务调用，例如 Facebook 的 Thrift，Google 的 gRPC 等。

4．利用标准的公有协议进行跨节点服务调用，例如 HTTP + XML、Restful + JSON 或者 WebService。

当前比较流行的序列化方式可以分为两大类:

1．文本类序列化方式：主要包括 JSON 和 XML，它们的优点是：支持跨语言、可读性好、配套的支持工具比较全。缺点就是：序列化之后的码流比较大、冗余内容多，性能相对比较差。

2．私有的二进制类序列化方式：比较流行的有 Thrift 序列化框架、MessagePack 和谷歌的 Protobuf 框架。它的优点是性能高，缺点就是可读性差，支撑的工具链不健全。

- RPC 、 WebService 、 RMI 、 JMS 的区别

RPC ，远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
简单来说就是一种编程模型，目的是解决分布式系统中服务之间的调用问题，使得远程调用和本地调用一样方便。
具体的实现，比如，Dubbo，它作为一个高性能高可靠的 RPC 框架，使用了 Zookeeper 作为注册中心，提供了多种负载均衡策略，还涉及到缓存、异步、线程等内容。

WebService 跨语言的系统间交互标准， HTTP 接口调用传输 XML ，所以无视平台和语言。

RMI ，Java 实现的一种远程过程调用的协议。底层 HTTP 但是只针对 Java 对象，在 TCP 协议上传递可序列化的 Java 对象，只能用在 JVM 上，绑定语言。

JMS ，Java 消息服务，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。
Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。

- RPC 框架与 HTTP 的区别

RPC 框架的优势首先就是长链接，不必每次通信都要像 HTTP 一样去3次握手，减少了网络开销；
其次就是RPC框架一般都有注册中心，有丰富的监控管理；
再者发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。

- 网络通信中数据传输序列化的方式

XML、JSON、protocol buffer、TLV（三元组编码）、自定义的格式

底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现。
其中传输协议比较出名的有 http、tcp、udp 等等。
http、tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议。
网络IO，主要有bio、nio、aio三种方式。
所有的分布式应用通讯都基于这个原理而实现，只是为了应用的易用性，各种语言通常都会提供一些更为贴近应用易用的应用层协议。

## 2.2 OkHttp 特性

OkHttp 3.12.x分支支持Android 2.3+（API级别9+）和Java 7+。这些平台不支持TLS 1.2，不应使用。

OkHttp 适用于 Android 5.0+（API级别21+）和 Java 8+。

- HTTP / 2支持允许对同一主机的所有请求共享套接字。
- 连接池减少了请求延迟（如果HTTP/2不可用）。
- 透明的 GZIP 缩小了下载大小。
- 响应缓存可以完全避免网络重复请求。

> 目前 OkHttp 仅支持在 https 请求下使用 HTTP 2.0。


OkHttp 依赖于 Okio 库，一个微小并且高性能的 I/O 库。


# 三、 拓展

## 3.1 http2.0

略

## 3.2 Okio 特性

OkHttp 的背后是一个叫做 Okio 的库，提供的 IO 支持。

OkIO是对于Java原生IO接口的一次封装。

Okio中特有的两个类Source，Sink代表的就是传统的输入流，和输出流。

Okio类相当于一个简单工厂，对外暴露接口，可以产生各式各样的Sink和Source。

Buffer的存储容器用的不是数组，而是Segment类对象构成的循环链表，Segment用了享元模式，有SegmentPool对Segment进行管理。

定时模块主要由Timeout和其子类AnsycTimeout类组成。

缓存是Okio中最重要的部分，缓存模块主要由Buffer，Segment，SegmentPool这三个类构成，Buffer内实际存储数据的容器是一条由Segment构成的的循环链表。暂时不用的Segment由SegmentPool通过单链表保存，防止频繁GC，避免内存抖动，增加资源的重复利用，提高效率。

对比Java IO和Okio我们可以看出OKio使用更方便，支持链式调用，代码简洁、优美。不需要把各种装饰类读写操作。数据容器采用循环链表实现，Segment通过分裂、合并、共享等操作避免了拷贝操作。SegmentPool会对暂时不用的Segment回收保存，避免频繁GC。支持阻塞IO和非阻塞IO，提供了一系列的方便工具，如GZip的透明处理，对数据计算md5、sha1等都提供了支持，对数据校验非常方便。

对`java.io`、`java.nio`的一个补充，更简单去访问、存储和处理你的数据

最初是作 HTTP客户端OkHttp的一个组件 。

Okio围绕两种类型构建，它们将大量功能集成到一个简单的API中：

`ByteString`是一个不可变的字节序列。可以很容易地将二进制数据变为一个值，它知道如何编码和解码为hex，base64和UTF-8。

`Buffer`是一个可变的字节序列。将数据写入末尾并从前面读取。不需要管理positions, limits, 或者 capacities.

ByteString 和 Buffer做了一些事情来节省CPU和内存。

如果将UTF-8字符串编码为一个ByteString，它会缓存对该字符串的引用，这样如果以后对其进行解码，则无需执行任何操作。

Buffer实现为分段的链表。将数据从一个缓冲区移动到另一个缓冲区时，它会重新分配段的所有权，而不是复制数据。这种方法对多线程程序特别有用：与网络通信的线程可以与工作线程交换数据而无需任何复制或仪式。

BufferSource分段读取socket的内容






- Base URL: 总是以 /结尾

- @Url: 不要以 / 开头

在Retrofit 2.0中，不管 response 是否能被解析。onResponse总是会被调用。

Buffer，Segment,SegmentPool

数据是通过Buffer写入一个叫Segment容器中的

SegmentPool,其实它的存在很简单，保存暂时不用的数据容器，防止频繁GC，基本上所有的XX池的作用的是这样，防止已申请的资源被回收，增加资源的重复利用，提高效率，减少GC,避免内存抖动




## 3.3 JAVA泛型与类型安全


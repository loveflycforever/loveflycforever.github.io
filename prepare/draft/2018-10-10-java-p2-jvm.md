---
layout: post
title:  "Java 虚拟机"
subtitle: "面试 Part 2 虚拟机"
tags: [Java, Interview]
comments: true
---
##### 2. 对象创建方法，对象的内存分配，对象的访问定位。

字段（成员变量/域）和属性有什么区别？

属性，是指对象的属性，对于JavaBean来说，是getXXX方法定义的
字段，是成员变量
``` java
public class Something {

    // title 是字段
    // 一般来说字段和属性相同
    private String title;

    // name 是属性
    public String getName() {
        return this.title;
    }
}
```

### 变量

本地变量是原始类型，那么它会被完全存储到栈区。

本地变量是一个对象的引用，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对象的成员方法，方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。

对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。

类变量（static）以及类本身相关信息都会随着类本身存储在堆区。

```
引用类型总是被分配到堆上，不论是成员变量（实例变量）还是局部变量（本地变量）。
基本数据类型总是分配到它声明的地方，成员变量在堆内存中，局部变量在栈内存中。
```

堆中的对象可以被多线程共享。如果一个线程获得一个对象的引用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。

对象创建方法：
    判断是否已经执行类加载：
        JVM遇到一条`new`指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类的加载过程。
    对象内存分配：
        当已经执行过类加载过程后，会为新对象在Java堆中分配一个大小已经确定的内存，具体的内存分配规则有两种：
            指针碰撞：
                如果Java堆中的内存是绝对规整的，所有用过的内存放一边，空闲的内存放到一边，中间放着指针为分界点。
                分配内存就是把指针向空闲的一边挪动一段与对象大小相等的距离。
            空闲列表：
                如果Java堆中的内存并不是规整对的，已使用的内存和空间相互交错，虚拟机会将可以用的内存维护到一个列表上。
                在分配内存时从这个列表中找到一块足够大的空间划给对象。然后更新列表记录。
        Java堆中的内存是否是规整的是根据虚拟机所采用的垃圾收集器是否带有压缩整理功能决定的。
        Serial、ParNew带压缩整理的分配内存用指针碰撞，CMS这种通常用空闲列表方式分配内存。
    防止并发：
        在虚拟机上创建对象是非常频繁的行为，所以要做到防止并发，有以下两种方式可实现：
            堆分配内存空间的动作进行同步处理，实际上JVM采用CAS（Compare And Set）配上失败重试的方式保证更新操作的原子性；
            把内存分配的动作按照线程划分在不同的空间之中进行，即为每个线程在Java堆中预先分配一块小内存，称为本地线程分配缓冲区（TLAB，Thread Local Allocation Buffer）。
            分配内存时在线程的TLBA上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。JVM是否使用TLAB可以通过-XX:+UseTLAB参数来设定。
    初始化对象内存空间：
        内存分配完成后，JVM将分配到的内存空间都初始化为零值（不包括对象头）。
    对象头的设置：
        将对象的类、哈希码、对象的GC分代年龄等信息设置到对象头之中。
    执行Java的init方法：
        设置完对象头后，从JVM的角度来看一个对象已经完成了，但是从Java程序的角度来看还没有创建完成呢。
        此时就需要执行init方法，调用构造方法等过程，这样一个真正可用的对象才算完全的产生出来。
对象的内存布局：
    对象在堆内存中的布局可分为三部分：对象头（Header），实例数据(Instance Data)，对齐填充(Padding)。
    对象头：对象头包含两部分，
        第一部分存储自身运行时数据，如哈希码，GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。
        第二部分是类型指针，即对象指向它的类元数据的指针，通过此指针来确定是哪个类的对象。
    实例数据：存储对象中的各类型的字段内容。无论是从父类继承来的还是在子类中定义的。
    对齐填充：并不是必然存在的，当对象实例数据部分没有对齐时，进行对齐补全。
对象的访问定位：
    Java程序需要通过栈上的reference数据来操作堆上的具体对象。reference数据只是一个指向对象的引用，具体的对象访问根据不同虚拟机有不同的实现，主流的访问方式有两种：使用句柄和直接指针。
    使用句柄：
        如果通过句柄来访问对象，Java堆中会划出一块内存作为句柄池，reference中存储句柄地址，而句柄中包含对象的实例数据与类型数据各自的地址。这样就能访问到对象了。
    直接指针：
        直接指针，就是指reference中直接存储对象的地址。但是Java堆对象的布局中就必须考虑如何防止访问类型数据相关信息。
这两种对象访问方式，各有优势，但是HotSpot使用的是指针对象访问，但是句柄访问对象在整个软件开发范围中也是十分常见的。






10. 分派：静态分派与动态分派。

编译期是指编译器将源代码翻译为机器能识别的代码，Java被编译为Jvm认识的字节码文件，运行期则是指Java代码的运行过程

JVM运行期动态加载+动态连接->Java的动态扩展特性

分派指的是在Java中对方法的调用，除了使用分派的方式对方法进行调用之外，还可以使用解析调用。
Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用
这个特性给 Java 带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接，也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。
静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析。
在 Java 语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。
Java 虚拟机里共提供了四条方法调用字节指令，分别是：
    invokestatic：调用静态方法。
    invokespecial：调用实例构造器方法、私有方法和父类方法。
    invokevirtual：调用所有的虚方法。
    invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。
这些方法可以称为非虚方法（还包括 final 方法），与之相反，其他方法就称为虚方法（final 方法除外）。
虽然调用 final 方法使用的是 invokevirtual 指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。Java 语言规范中明确说明了 final 方法是一种非虚方法。
解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。
而分派调用则既可以是静态的也可以是动态（就是这里的静态分派和动态分派）的。
根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。
分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。
Human man = new Man（）;
其中的“Human”称为变量的静态类型，后面的“Man”称为变量的实际类型。
“重载”，静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定。
静态类型相同、实际类型不同的变量，编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。
静态类型是编译期可知的，所以在编译阶段，javac 编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用。
man.say();
重写”，此时要根据变量的实际类型来分派方法的执行版本的，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法。其中实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。但分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。
静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型，二是方法参数类型。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。
动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。
类在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable），使用虚方法表索引来代替元数据查找以提高性能。
虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实际入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实际版本的入口地址。
为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。
方法表一般在类加载阶段的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。


























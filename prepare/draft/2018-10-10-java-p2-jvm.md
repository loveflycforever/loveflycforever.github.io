---
layout: post
title:  "Java 虚拟机"
subtitle: "面试 Part 2 虚拟机"
tags: [Java, Interview]
comments: true
---
1. 内存模型以及分区（需要详细到每个区放什么）

Java内存模型（JMM，Java Memory Model）本身是一种抽象的概念。定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方式。

- 规定了一个线程如何以及何时可以看到其他线程修改过后的共享变量的值，即线程之间共享变量的可见性。
- 如何在需要的时候对共享变量进行同步。

    在并发编程中，要处理的两个关键问题就是这两条标准的体现：线程之间如何通信以及线程之间如何同步。
    通信是指线程之间以何种机制来交换信息。
    在命令式的编程中，线程之间的通信机制有两种：共享内存和消息传递。
    
    在共享内存并发的模型里，线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式进行通信。典型的共享内存通信方式就是通过共享对象进行通信。
    在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显示进行通信，在java中典型的消息传递方式就是wait()和notify()。

    同步是指程序用于控制不同线程之间操作发生相对顺序的机制。
    在共享内存并发模型里，同步是显示进行的，开发人员必须显示指定某个方法或某段代码需要在线程之间互斥进行。
    在消息传递的并发模型里，由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。
    Java的并发采用的就是共享内存模型。
    
这里的共享内存模型指的就是Java内存模型(简称JMM)，
JMM决定一个线程对共享变量的写入何时对另一个线程可见。
从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：
线程之间的共享变量存储在主内存（main memory）中，
每个线程都有一个私有的本地内存（local memory），
本地内存中存储了该线程以读/写共享变量的副本。
本地内存是JMM的一个抽象概念，并不真实存在。
它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

Java内存模型，通常是指Java程序在运行时内存的模型，
而Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行（解释器）或编译执行（即时编译器）来完成，
故Java内存模型，也就是指Java虚拟机的运行时内存模型。

Java内存模型中分为__主内存__和__工作内存__。

主内存，主内存里面存储着所有变量，主内存是共享内存区域，所有线程都可以访问。

工作内存，每一个线程都私有一个工作内存，工作内存里面保存着主内存里面变量值的副本。

__线程对变量的操作都是在工作内存中完成，操作结束后再放回主内存__。

主内存可粗略认为是堆，工作内存认为是栈。

Java虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域有自己的用途，以及创建和销毁时间。

有的区域随着Java虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。

Java虚拟机栈（JVM Stack）

    Java虚拟机栈，它是线程私有的，生命周期与线程相同。
    一个线程的每个方法在执行的同时，都会创建一个栈帧（Stack Frame），
    栈帧中存储的有局部变量表、操作栈、动态链接、方法出口等
    当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈
        局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。
        在局部变量表中，只有`long`和`double`类型会占用2个__局部变量空间__（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。
        局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。
    会有两种异常`StackOverFlowError`和`OutOfMemoryError`。
        当线程请求栈深度大于虚拟机所允许的深度就会抛出`StackOverFlowError`错误；
        虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出`OutOfMemoryError`错误。

本地方法栈（Native Method Stack）

    本地方法栈的作用，运行机制，异常类型等方面都与虚拟机栈相同
    虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，
    在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。
    在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。
    本地方法栈也是线程私有的。
    本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

    native方法，被native关键字修饰的方法叫做本地方法，本地方法和其它方法不一样，本地方法意味着和平台有关，因此使用了native的程序可移植性都不太高。
    另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的本地方法栈。
    native方法主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。
    被native修饰的方法可以被C语言重写。

    使用步骤

    1. Java程序中声明native修饰的方法，类似于abstract修饰的方法，只有方法签名，没有方法实现。编译该java文件，会产生一个.class文件。
    2. 使用javah编译上一步产生的class文件，会产生一个.h文件。
    3. 写一个.cpp文件实现上一步中.h文件中的方法。
    4. 将上一步的.cpp文件编译成动态链接库文件.dll。
    5. 最后就可以使用System或是Runtime中的loadLibrary()方法加载上一步的产生的动态连接库文件了。

堆区（Heap）

    在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域
    堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。
    堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。
    堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。
    如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，会抛出异常OutOfMemoryError:Java heap space

方法区（Method Area）

    被所有线程共享区域，用于存放已被虚拟机加载的类信息，final常量，静态变量，编译器即时编译的代码等数据。
    被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（PermGen，permanent generation）
    （由于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。）
    垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池内存回收，类型卸载。
    常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern()方法。
    在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。

程序计数器（Program Counter Register）

    用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。
    通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。
    为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。
    程序计数器只是记录当前指令地址，因此是唯一一块Java虚拟机没有规定任何OutOfMemoryError的区块

直接内存（Direct Memory）

    直接内存并不是JVM管理的内存，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，
    JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。
    由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。

备注：
方法区物理上存在于堆里，而且是在堆的持久代里面；但在逻辑上，方法区和堆是独立的。 一般说堆的持久代就是说方法区，因为一旦JVM把方法区（类信息，常量池，静态字段，方法）加载进内存以后，这些内存一般是不会被回收的了。

虚拟机线程（VM thread），线程都需要 JVM 位于安全点。有：stop-the-world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。

HotSpot虚拟机使用了直接指针的方式访问对象

2. 对象创建方法，对象的内存分配，对象的访问定位。
对象创建方法：
    判断是否已经执行类加载：
        JVM遇到一条`new`指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类的加载过程。
    对象内存分配：
        当已经执行过类加载过程后，会为新对象在Java堆中分配一个大小已经确定的内存，具体的内存分配规则有两种：
            指针碰撞：
                如果Java堆中的内存是绝对规整的，所有用过的内存放一边，空闲的内存放到一边，中间放着指针为分界点。
                分配内存就是把指针向空闲的一边挪动一段与对象大小相等的距离。
            空闲列表：
                如果Java堆中的内存并不是规整对的，已使用的内存和空间相互交错，虚拟机会将可以用的内存维护到一个列表上。
                在分配内存时从这个列表中找到一块足够大的空间划给对象。然后更新列表记录。
        Java堆中的内存是否是规整的是根据虚拟机所采用的垃圾收集器是否带有压缩整理功能决定的。
        Serial、ParNew带压缩整理的分配内存用指针碰撞，CMS这种通常用空闲列表方式分配内存。
    防止并发：
        在虚拟机上创建对象是非常频繁的行为，所以要做到防止并发，有以下两种方式可实现：
            堆分配内存空间的动作进行同步处理，实际上JVM采用CAS（Compare And Set）配上失败重试的方式保证更新操作的原子性；
            把内存分配的动作按照线程划分在不同的空间之中进行，即为每个线程在Java堆中预先分配一块小内存，称为本地线程分配缓冲区（TLAB，Thread Local Allocation Buffer）。
            分配内存时在线程的TLBA上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。JVM是否使用TLAB可以通过-XX:+UseTLAB参数来设定。
    初始化对象内存空间：
        内存分配完成后，JVM将分配到的内存空间都初始化为零值（不包括对象头）。
    对象头的设置：
        将对象的类、哈希码、对象的GC分代年龄等信息设置到对象头之中。
    执行Java的init方法：
        设置完对象头后，从JVM的角度来看一个对象已经完成了，但是从Java程序的角度来看还没有创建完成呢。
        此时就需要执行init方法，调用构造方法等过程，这样一个真正可用的对象才算完全的产生出来。
对象的内存布局：
    对象在堆内存中的布局可分为三部分：对象头（Header），实例数据(Instance Data)，对齐填充(Padding)。
    对象头：对象头包含两部分，
        第一部分存储自身运行时数据，如哈希码，GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。
        第二部分是类型指针，即对象指向它的类元数据的指针，通过此指针来确定是哪个类的对象。
    实例数据：存储对象中的各类型的字段内容。无论是从父类继承来的还是在子类中定义的。
    对齐填充：并不是必然存在的，当对象实例数据部分没有对齐时，进行对齐补全。
对象的访问定位：
    Java程序需要通过栈上的reference数据来操作堆上的具体对象。reference数据只是一个指向对象的引用，具体的对象访问根据不同虚拟机有不同的实现，主流的访问方式有两种：使用句柄和直接指针。
    使用句柄：
        如果通过句柄来访问对象，Java堆中会划出一块内存作为句柄池，reference中存储句柄地址，而句柄中包含对象的实例数据与类型数据各自的地址。这样就能访问到对象了。
    直接指针：
        直接指针，就是指reference中直接存储对象的地址。但是Java堆对象的布局中就必须考虑如何防止访问类型数据相关信息。
这两种对象访问方式，各有优势，但是HotSpot使用的是指针对象访问，但是句柄访问对象在整个软件开发范围中也是十分常见的。

3. GC的两种判定方法：引用计数与引用链（可达性分析）。
Java的一个重要优点就是通过垃圾收集器(Garbage Collection，GC)自动管理内存的回收。
Java的内存管理就是对象的分配和释放问题。
在Java中，需要通过关键字`new`为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由GC决定和执行的。
在Java中，内存的分配是由程序完成的，而内存的释放是有GC完成的，这种收支两条线的方法确实简化了程序员的工作，但同时，它也加重了JVM的工作，这也是Java程序运行速度较慢的原因之一。
因为，GC为了能够正确释放对象，GC必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。
引用计数：在JDK1.2之前
    当这个类被加载到内存之后，就会产生方法区，堆栈、程序计数器等一系列信息，
    当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，
    当有新的引用时，引用计数器继续+1，而当其中一个引用销毁时，引用计数器-1，
    当引用计数器减为0的时候，标志着这个对象已经没有引用了，可以回收
    但是很难解决对象之间循环相互引用的问题（ObjA.obj=ObjB; ObjB.obj=ObjA，两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了）。
可达性分析算法：根搜索算法是从离散数学中的图论引入
    程序把所有的引用关系看做一张图，从一个节点GC Root开始，寻找对应的引用节点，找到这个节点之后，继续寻找这个节点的引用节点，
    当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被饮用到的节点，即无用的节点。
    目前Java中可作为GC Root的对象有：
        虚拟机栈中引用的对象（本地变量表）
        方法区中静态属性引用的对象
        方法区中常量引用的对象
        本地方法栈中引用的对象(Native对象)。
方法区中主要存放类与类之间关系的数据，而这部分数据加载到内存之后，基本上是不会发生变更的
Java堆中的数据基本上是朝生夕死的，我们用完之后要马上回收的
Java栈和本地方法栈中的数据，因为有后进先出的原则，当我取下面的数据之前，必须要把栈顶的元素出栈，因此回收率可认为是100%
程序计数器主要记录程序执行的行号要跳转的地址等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域
注意：
方法区中的数据回收率比较低，而成本又比较高，一般认为“性价比”比较差的，所以SUN自己的虚拟机HotSpot中是不可回收的
但是现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理等这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久不会溢出，
他们通过自定义的类加载器进行了各种操作，因此在实际的应用开发中，类也是经常被加载和卸载的，方法区也是会被回收的
方法区中的回收条件非常苛刻，只有同时满足以下三个条件才会被回收：
    1.所有实例被回收
    2.加载该类的ClassLoader被回收
    3.Class对象无法通过任何途径访问（包括 反射）

java 安全点
- 循环的末尾
- 方法临返回前/调用方法之后
- 抛异常的位置


如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？
主要有两种方式：

抢断式中断：在 GC 发生时，首先中断所有线程，如果发现线程未执行到 Safe Point，就恢复线程让其运行到 Safe Point 上。

主动式中断：在 GC 发生时，不直接操作线程中断，而是简单地设置一个标志，让各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。

JVM 采取的就是主动式中断。轮询标志的地方和安全点是重合的。


可达性分析
保守式GC：

准确式GC：
在java中实现的方式是：从外部记录下类型信息，存成映射表，在HotSpot中把这种映射表称之为OopMap，不同的虚拟机名称可能不一样，
实现这种功能，需要虚拟机的解释器和JIT编译器支持，由他们来生成OopMap。生成这样的映射表一般有两种方式：
每次都遍历原始的映射表，循环的一个个偏移量扫描过去；这种用法也叫“解释式”； 
为每个映射表生成一块定制的扫描代码（想像扫描映射表的循环被展开的样子），以后每次要用映射表就直接执行生成的扫描代码；这种用法也叫“编译式”。
GC开始的时候，就通过OopMap这样的一个映射表知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录下栈和寄存器中哪些位置是引用


安全区域
安全点的使用似乎解决了OopMap计算的效率的问题，但是这里还有一个问题。
安全点需要程序自己跑过去，处在Sleep或者Blocked状态的线程，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上，他们可能并不会在很短的时间内跑到安全点去。
所以这里为了解决这个问题，又引入了安全区域的概念。

安全区域很好理解，就是在程序的一段代码片段中并不会导致引用关系发生变化，也就不用去更新OopMap表了，那么在这段代码区域内任何地方进行GC都是没有问题的。
这段区域就称之为安全区域。

线程在进入 Safe Region 的时候先标记自己已进入了 Safe Region，等到被唤醒时准备离开 Safe Region 时，先检查能否离开，
如果 GC 完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。

4. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
标记-清除算法（Mark-Sweep）
    从根节点开始标记所有可达对象，其余没有标记的即为垃圾对象，执行清除。但回收后的空间是不连续的。
    标记-清除算法采用从根集合进行扫描，对存活的对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。
    标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
复制算法
    复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中
    这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间进行对象的移动。也就是s0，s1等空间
标记-整理法
    标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时，在回收不存活的对象占用的空间后，会将所有的存活对象网左端空闲空间移动，并更新相应的指针。
    标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。
    
5. GC收集器有哪些？CMS收集器与G1收集器的特点。
在一个应用程序中，不同的对象存在的时间，或者说每个对象的生命周期都是不同的。
有些对象生命周期很短，比如Web应用程序中的request对象，它的生命周期和请求是对应的，当请求完成以后，该request对象就结束了它的职责，需要被收集器回收。
有些对象的生命周期很长，比如一些全局的对象，可能会伴随整个应用程序的生命周期而存在。
大部分的对象的生命周期都很短，而生命周期长的对象，它们的数量占据了小部分
现代JVM的对不同生命周期的对象进行分类，对堆内存区域进行逻辑划分。按照对象的存活时间长短，将内存分为：年轻代、老年代和永久代（在Java8中去掉了永久代，以元数据空间代替）。
JVM提供了两个参数来控制JVM堆的大小：-XX:InitialHeapSize（-Xms）和-XX:MaxHeapSize(-Xmx)。JVM会根据应用程序使用内存的情况，动态扩展堆内存的大小。
可以将JVM的堆内存设置为256M，最大512M的大小，那么可以这么设置：-Xms256m -Xmx512m。如果将Xms的值和Xmx的值设置为相同，那么JVM将不能动态扩展堆内存，它的初始堆内存和最大堆内存是相同的。
通过参数NewRatio来按比例控制年轻代的大小，NewRatio的值表示年轻代和老年代的比值，比如：-XX:NewRatio=6 就表示，年轻代:老年代 = 1:6
年轻代
    在年轻代中，又将内存细分为Eden区和2个Survivor区。
    正常情况下，对象都是在Eden区被分配的。由于在年轻代，GC算法采用的是“标记-复制”算法，所以划分出了两个Survivor区，用于在执行复制算法的时候交替存放存活的对象。
    在JVM运行的时候，在年轻代，只有Eden区和其中的一个Survivor区会被使用，而另外一个Surviro区是闲置的。当在年轻代进行GC的时候，会将这次GC以后存活的对象移动到其中闲置的Survivor区中，然后清空Eden区和之前的Survivor区。这样，就可以保证每次都有一快空闲的内存用于复制。
    JVM参数NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小。
    通过SurvivorRatio这个参数来控制两块区域的大小。比如：-XX:SurvivorRatio = 8，那么表示Eden : 一个Survivor = 8 : 1，那么Eden区就占据了年轻代中的8 / 10，而两个Survivor区分别占据了 1 / 10。
    一般把在年轻代中进行的GC称为Minor GC。
老年代
    当对象在年轻代中经历了多次Minor GC以后仍旧存活，那么当达到一定的年龄（经历过一次Minor GC，年龄加1）以后，仍旧存活的对象就会被移动到老年代中。
    正常情况下，在老年代的GC不会像年轻代那么频繁，老年代的GC收集器，一般采用"标记-清除"算法或"标记-整理"算法来回收垃圾对象。
    老年代中的对象，除了通过年轻代提升上来的长生命周期的对象以外，在一些特殊的情况下，也会在老年代中直接分配对象。
    老年代的GC我们一般称为Major GC。
Serial收集器
    是针对新生代的收集器，采用的是复制算法
    Serial收集器是最基本的收集器，这是一个单线程收集器
    它“单线程”的意义不仅仅是说明它只用一个线程去完成垃圾收集工作，更重要的是在它进行垃圾收集工作时，必须暂停其他工作线程，直到它收集完成。
    Sun将这件事称之为”Stop the world“。
    没有一个收集器能完全不停顿，只是停顿的时间长短。
    Serial收集器的缺点很明显，但是它仍然是JVM在Client模式下的默认新生代收集器。
    它有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比较），Serial收集器由于没有线程交互的开销，减少了很多线程的上下文切换的开销，专心只做垃圾收集自然也获得最高的效率。
    在用户桌面场景下，分配给JVM的内存不会太多，停顿时间完全可以在几十到一百多毫秒之间，只要收集不频繁，这是完全可以接受的。   
ParNew收集器
    ParNew是Serial的多线程版本，在回收算法、对象分配原则上都是一致的。
    ParNew收集器是许多运行在Server模式下的默认新生代垃圾收集器，其主要在于除了Serial收集器，目前多线程版本的年轻代收集器中只有ParNew收集器能够与CMS收集器配合工作。 
    当它运行在单CPU的机器上的时候，由于不能利用多核的优势，在线程收集过程中可能会出现频繁上下文切换，导致额外的开销，所以在单CPU的机器上，ParNew收集器的性能不一定好于Serial这款单线程收集器。
    ParNew收集器默认开启的垃圾收集线程数是和当前机器的CPU数量相同的，为了控制GC收集线程的数量，可以通过参数-XX:ParallelGCThreads来控制垃圾收集线程的数量。
Parallel Scavenge收集器
    是针对新生代的收集器，采用的是复制算法，也是并行的多线程收集器。
    Parallel Scavenge 收集器更关注可控制的吞吐量，被称为吞吐量优先收集器。
    吞吐量等于运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)。
    直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，但是GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。
    比如原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间下降的同时，吞吐量也下降了。
    停顿时间越短就越适合需要与用户交互的程序；而高吞吐量则可以最高效的利用CPU的时间，尽快的完成计算任务，主要适用于后台运算。
    通过-XX:MaxGCPauseMillis用于控制最大垃圾收集停顿时间，-XX:GCTimeRatio用于直接控制吞吐量的大小。
    MaxGCPauseMillis参数的值允许是一个大于0的整数，表示毫秒数，收集器会尽可能的保证每次垃圾收集耗费的时间不超过这个设定值。如果设定的过小，那么收集器为了保证每次垃圾收集的时间不超过这个限定值，会导致垃圾收集的次数增加和增加年轻代的空间大小，垃圾收集的吞吐量也会随之下降。
    GCTimeRatio这个参数的值应该是一个0-100之间的整数，表示应用程序运行时间和垃圾收集时间的比值。如果把值设置为19，即系统运行时间 : GC收集时间 = 19 : 1，那么GC收集时间就占用了总时间的5%(1 / (19 + 1) = 5%)，该参数的默认值为99，即最大允许1%(1 / (1 + 99) = 1%)的垃圾收集时间。
    通过-XX:UseAdaptiveSizePolicy开启这个参数以后，就不需要手动指定新生代的内存大小(-Xmn)、Eden区和Survivor区的比值(-XX:SurvivorRatio)以及晋升到老年代的对象的大小(-XX:PretenureSizeThreshold)等参数了，虚拟机会根据当前系统的运行情况动态调整合适的设置值来达到合适的停顿时间和合适的吞吐量，这种方式称为GC自适应调节策略。
Serial Old收集器
    Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。
    主要是在JDK1.5版本之前和Parallel Scavenge年轻代收集器配合使用，或者作为CMS收集器的后备收集器。
Parallel Old收集器
    Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法进行垃圾回收。
    在JDK1.6之后，其通常与Parallel Scavenge收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。
CMS 收集器
    CMS（Concurrent Mark Sweep）收集器是一种以获取最短停顿时间为目标的收集器，CMS收集器采用标记--清除算法，运行在老年代。
    由于现代互联网中的应用，比较重视服务的响应速度和系统的停顿时间，所以CMS收集器非常适合在这种场景下使用。
    主要包含以下几个步骤：· 初始标记· 并发标记· 重新标记· 并发清除
    其中初始标记和重新标记仍然需要“Stop the world”。
    初始标记仅仅标记GC Root能直接关联的对象，速度很快。
    并发标记就是进行GC Root Tracing过程，会从GC Roots 出发，标记处所有可达的对象，这个过程可能会花费相对比较长的时间，但是由于在这个阶段，GC线程和用户线程是可以一起运行的，所以即使标记过程比较耗时，也不会影响到系统的运行。
    重新标记则是为了修正并发标记期间，因用户程序继续运行而导致标记变动的那部分对象的标记记录，只是修改之前 并发标记 所获得的不可达对象，重新标记阶段耗时一般比初始标记稍长，但是远小于并发标记阶段。
    并发清理阶段不会停止系统的运行，所以即使相对耗时，也不会对系统运行产生大的影响。
    整个过程中最耗时的并发标记和并发清除，收集线程和用户线程一起工作，所以总体上来说，CMS收集器回收过程是与用户线程并发执行的。
    CMS优点是并发收集、低停顿，很大程度上已经是一个不错的垃圾收集器，但是还是有三个显著的缺点：
        CMS收集器对CPU资源很敏感。在并发阶段，虽然它不会导致用户线程停顿，但是会因为占用一部分线程（CPU资源）而导致应用程序变慢，会导致系统总的吞吐量降低。
            CMS默认开始的回收线程数是(Ncpu + 3) / 4，其中Ncpu是机器的CPU数。所以，当机器的CPU数量为4个以上的时候，垃圾回收线程将占用不少于%25的CPU资源，并且随着CPU数量的增加，垃圾回收线程占用的CPU资源会减少。但是，当CPU资源少于4个的时候，垃圾回收线程占用的CPU资源的比例会增大，会影响到系统的运行，假设有2个CPU的情况下，垃圾回收线程将会占据超过50%的CPU资源。所以，在选用CMS收集器的时候，需要考虑，当前的应用系统，是否对CPU资源敏感。
        CMS收集器不能处理浮动垃圾，也是由于这个原因，即还需要预留足够的内存空间用于存放浮动垃圾，因此CMS收集器不能像其他收集器那样等到老年代几乎填满才进行收集。要是CMS预留的内存空间不能满足程序的要求，所以可能会出现Concurrent Mode Failure问题而导致触发一次Full GC，这时JVM就会启动预备方案：临时启动Serial Old收集器来收集老年代，这样停顿的时间就会很长，特别是当老年代内存很大的时候。。
            所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们，只好在下一次GC的时候处理，这部分未处理的垃圾就称为“浮动垃圾”。
            在JDK 1.5中，默认当老年代使用了68%的时候会激活垃圾收集，通过参数"-XX:CMSInitiatingOccupancyFraction"控制触发的百分比，在JDK 1.6中，CMS收集器的激活阀值变成了92%。
            对参数"-XX:CMSInitiatingOccupancyFraction"的设置，过高，会导致发生Concurrent Mode Failure，过低，则浪费内存空间。
        由于CMS使用标记--清除算法，所以在收集之后会产生大量内存碎片。当内存碎片过多时，将会给分配大对象带来困难，这是就会进行Full GC。
            提供了一个"-XX:+UseCMSCompactAtFullCollection"参数，默认是开启的，用于CMS收集器在必要的时候对内存碎片进行压缩整理。由于内存碎片整理过程不是并发的，所以会导致停顿时间变长。
            还提供了一个"-XX:CMSFullGCsBeforeCompaction"参数，来控制进行过多少次不压缩的Full GC以后，进行一次带压缩的Full GC，默认值是0，表示每次在进行Full GC前都进行碎片整理。
G1收集器
    G1收集器与CMS相比有很大的改进，G1收集器采用标记--整理算法实现。局部采用复制。可以非常精确地控制停顿。
    G1收集器将Java堆（包括新生代和老年代）划分为多个区域（Region），并在后台维护一个优先列表，每次根据允许的时间，优先回收垃圾最多的区域 。
    G1将新生代，老年代的物理空间划分取消了，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，
    新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。
    老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。
    这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。
    G1收集器可以实现在基本不牺牲吞吐量的情况下完成低停顿的内存回收，这是由于它极力的避免全区域的回收
    如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。
    这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。
    G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
    在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间。
    G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。
    Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。
    在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。
    G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。
    在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。
    G1中使用point-in来解决。point-in的意思是哪些年老分区引用了当前年轻分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。不需要在新生代之间记录引用，因为在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。
    卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。
    一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。
        阶段1：根扫描
        静态和本地对象被扫描
        阶段2：更新RS
        处理dirty card队列更新RS
        阶段3：处理RS
        检测从年轻代指向年老代的对象
        阶段4：对象拷贝
        拷贝存活的对象到survivor/old区域
        阶段5：处理引用队列
        软引用，弱引用，虚引用处理
    Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。
    在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。
        初始标记（initial mark，STW）
        在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。
        根区域扫描（root region scan）
        G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。
        并发标记（Concurrent Marking）
        G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断
        最终标记（Remark，STW）
        该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。
        清除垃圾（Cleanup，STW）
        在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。
并发标记，三色标记算法，黑色:根对象，或者该对象与它的子对象都被扫描，灰色:对象本身被扫描,但还没扫描完该对象中的子对象，白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象
两种保证应用程序在运行的时候，GC标记的对象不丢失的方案：在插入的时候记录对象；在删除的时候记录对象
在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。
在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：1，在开始标记的时候生成一个快照图标记存活对象；2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）；3，可能存在游离的垃圾，将在下次被收集
这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。
默认，JVM不会打印出GC日志信息，可以通过参数-XX:+PrintGC或-verbose:gc来设置JVM输出gc日志到终端中。JVM参数：-XX:+PrintGC -XX:+PrintGCDetails -XX:+UseSerialGC -Xms10m -Xmx10m
    
6. Minor GC与Full GC分别在什么时候发生？
从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。
Major GC 是清理老年代。
Full GC 是清理整个堆空间—包括年轻代和老年代。
当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。
Full GC触发条件：
    调用System.gc时，系统建议执行Full GC，但是不必然执行
    老年代空间不足
    方法区空间不足
    通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

7. 几种常用的内存调试工具：jmap、jstack、jconsole。
jps 用来查看基于HotSpot JVM里面所有进程的具体状态, 包括进程ID，进程启动的路径等等。
jstat 主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。
jstack 用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息
jmap 打印出某个java进程（使用pid）内存内的，所有对象的情况（如：产生那些对象，及其数量）。
jinfo 可以输出并修改运行时的java 进程的opts。用处比较简单，用于输出JAVA系统参数及命令行参数。
jconsole 一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。
jvisualvm 同jconsole都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具
jhat 用于对JAVA heap进行离线分析的工具，他可以对不同虚拟机中导出的heap信息文件进行分析，
Jdb 用来对core文件和正在运行的Java进程进行实时地调试，里面包含了丰富的命令帮助您进行调试

8. 类加载的五个过程：加载、验证、准备、解析、初始化。
1)  加载：根据查找路径找到相应的class文件，然后导入。类的加载方式分为隐式加载和显示加载两种。
    隐式加载指的是程序在使用new关键词创建对象时，会隐式的调用类的加载器把对应的类加载到jvm中。
    显示加载指的是通过直接调用class.forName()方法来把所需的类加载到jvm中。
    1.通过一个类的全限定名来获取定义此类的二进制字节流。
    2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中，经由验证、准备和解析三个阶段。
2)  检查：检查夹加载的class文件的正确性。
    1.文件格式验证：
    （1）是否以魔数0xCAFEBABE开头。
    （2）主、次版本号是否在当前虚拟机处理范围之内。
    （3）常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
    （4）指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
    （5）CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。
    （6）Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
    2.元数据验证：
    （1）这个类是否有父类（除了java.lang.Object之外，所有类都应当有父类）。
    （2）这个类是否继承了不允许被继承的类（被final修饰的类）。
    （3）如果这个类不是抽象类，是否实现了其父类或接口之中所要求实现的所有方法。
    （4）类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等等）。
    3.字节码验证：
    主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会产生危害虚拟机安全的事件，例如：
    （1）保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作数栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
    （2）保证跳转指令不会跳转到方法体以外的字节码指令上。
    （3）保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险不合法的。
    (Halting Problem:通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确的检查出程序是否能在有限时间之内结束运行。）
    4.符号引用验证：
    符号引用验证可以看作是类对自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容：
    （1）符号引用中通过字符串描述的全限定名是否能够找到对应的类。
    （2）在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
    （3）符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。
3)  准备；给类中的静态变量分配内存空间。
    这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中。
4)  解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。
5)  初始化：对静态变量和静态代码块执行初始化工作。
    这里的初始化是执行类构造器<clinit>。<clinit>()方法是编译器自动收集类中所有类变量的赋值动作和静态代码块而产生的方法（无论类变量和静态代码块的位置是什么样，都是先执行类变量的赋值动作，再执行静态代码块）

9. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader。
启动类加载器 Bootstrap ClassLoader：加载<JAVA_HOME>\lib目录下核心库
扩展类加载器 Extension ClassLoader：加载<JAVA_HOME>\lib\ext目录下扩展包
应用程序类加载器 Application ClassLoader：加载用户路径(classpath)上指定的类库
工作流程：
    当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。  
    当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。  
    如果Bootstrap ClassLoader加载失败(在<JAVA_HOME>\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。  
    如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。
    如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。  
    如果均加载失败，就会抛出ClassNotFoundException异常。 
实现过程：
    实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中：  
    首先会检查请求加载的类是否已经被加载过；  
    若没有被加载过：  
    递归调用父类加载器的loadClass();  
    父类加载器为空后就使用启动类加载器加载；  
    如果父类加载器和启动类加载器均无法加载请求，则调用自身的加载功能。
优点：
Java类伴随其类加载器具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序。  
保证了运行的安全性，防止不可信类扮演可信任的类。

10. 分派：静态分派与动态分派。
分派指的是在Java中对方法的调用，除了使用分派的方式对方法进行调用之外，还可以使用解析调用。
Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用
这个特性给 Java 带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接，也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。
静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析。
在 Java 语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。
Java 虚拟机里共提供了四条方法调用字节指令，分别是：
    invokestatic：调用静态方法。
    invokespecial：调用实例构造器方法、私有方法和父类方法。
    invokevirtual：调用所有的虚方法。
    invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。
这些方法可以称为非虚方法（还包括 final 方法），与之相反，其他方法就称为虚方法（final 方法除外）。
虽然调用 final 方法使用的是 invokevirtual 指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。Java 语言规范中明确说明了 final 方法是一种非虚方法。
解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。
而分派调用则既可以是静态的也可以是动态（就是这里的静态分派和动态分派）的。
根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。
分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。
Human man = new Man（）;
其中的“Human”称为变量的静态类型，后面的“Man”称为变量的实际类型。
“重载”，静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定。
静态类型相同、实际类型不同的变量，编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。
静态类型是编译期可知的，所以在编译阶段，javac 编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用。
man.say();
重写”，此时要根据变量的实际类型来分派方法的执行版本的，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法。其中实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。但分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。
静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型，二是方法参数类型。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。
动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。
类在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable），使用虚方法表索引来代替元数据查找以提高性能。
虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实际入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实际版本的入口地址。
为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。
方法表一般在类加载阶段的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。


11.Java 语言的一本著名书籍《Practical Java》中把 “不使用的对象应手动赋值为 null” 作为一条推荐的编码规则。
``` java
public static void main(String[] args) {  
    byte[] placeholder = new byte[64 * 1024 * 1024];  
    System.gc();  
} 
```

``` java
public static void main(String[] args) {
	{
		byte[] placeholder = new byte[64 * 1024 * 1024];
	}
	System.gc();
}
```

``` java
public static void main(String[] args) {
	{
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    int a = 0;
    System.gc();
}
```

在如上代码中，placeholder 能否被回收的根本原因是：局部变量中的 Slot 是否还存在关于 placeholder 数组对象的引用。第一次修

改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，没有任何局部变量表的读写操作，placeholder 原本占用的 Slot 还没有

被其他变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都

很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量的内存、实际上已经不会再使用的变量，

手动将其设置为 null 值（用来代替那句 int a=0，把变量对应的局部变量表 Slot 清空）便不见得是一个绝对无意义的操作，这种操作可

以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到 JIT 的编译条件）下的 “奇技” 来

使用。

























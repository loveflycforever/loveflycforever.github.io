---
layout: post
title:  " Java 内存模型和 Java 内存结构"
subtitle: ""
tags: [Java, JMM, JVM]
comments: true
---
# Java 内存模型和 Java 内存结构
## 内存模型

### 计算机内部的缓存架构

计算机的 CPU 数量可能会是2个或以上，而且每个 CPU 又会包含多个核心。因而，一个多线程应用的线程可能会分布在不同 CPU 的不同核心中并行运行。

当 CPU 需要访问主存（RAM）时，会先读取一部分主存数据到 CPU 缓存（CPU Cache，多级缓存，一般分为L1、L2、L3缓存），进而在读取 CPU缓存  中的数据到 寄存器（Register）。

当 CPU 需要写数据到主存时，同样会先 flush 寄存器 到 CPU缓存，然后再在某些节点把缓存数据 flush 到 主存。

因为这些缓存的存在，提供了数据的访问性能，也减轻了数据总线上数据传输的压力。

内存模型可以理解为在特定的操作协议下，__对特定的内存或者高速缓存进行读写访问的过程抽象__。

比如，两个CPU同时去操作同一个内存地址，会在各自的Cache中缓存同一份数据的拷贝，如果其中一个CPU修改了这部分数据，这时就使得这两份缓存的数据不同，也就是另一个CPU Cache中的数据失效了。

内存模型定义了一个充分必要条件，保证其它CPU的写入动作对该CPU是可见的，而且该CPU的写入动作对其它CPU也是可见的。

不同架构下的物理机拥有不一样的内存模型。

### 硬件内存模型

#### 强内存模型

有些处理器提供了强内存模型，所有CPU在任何时候都能看到内存中任意位置相同的值，这种完全是硬件提供的支持。

#### 弱内存模型

其它处理器，提供了弱内存模型，需要执行一些特殊指令（memory barriers内存屏障），刷新CPU缓存的数据到内存中，保证这个写操作能够被其它CPU可见，或者将CPU缓存的数据设置为无效状态，保证其它CPU的写操作对本CPU可见。通常这些内存屏障的行为由底层实现，对于上层语言的程序员来说是透明的（不需要太关心具体的内存屏障如何实现）。

### 并发编程

在并发编程中，要处理的两个关键问题就是这两条标准的体现：线程之间如何通信以及线程之间如何同步。

#### 线程之间如何通信

通信是指线程之间以何种机制来交换信息。

在命令式的编程中，线程之间的通信机制有两种：共享内存和消息传递。

##### 共享内存 模型

在 共享内存 并发的模型里，线程之间共享程序的公共状态，线程之间通过读/写内存中的公共状态来隐式进行通信。典型的共享内存通信方式就是通过共享对象进行通信。

##### 消息传递 模型

在 消息传递 的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显示进行通信，在 Java 中典型的消息传递方式就是`wait()`和`notify()`。

#### 线程之间如何同步

同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

##### 共享内存 模型

在 共享内存 并发模型里，同步是显示进行的，开发者必须显示指定某个方法或某段代码需要在线程之间互斥进行。

##### 消息传递 模型

在 消息传递 的并发模型里，由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。


## Java内存模型
Java 内存模型（JMM，Java Memory Model）本身是一种抽象的概念。

指的是 JDK 5 开始使用的新的内存模型，主要由` JSR-133: JavaTM Memory Model and Thread Specification`描述。

在C/C++语言中直接使用物理硬件和操作系统内存模型，导致不同平台下并发访问出错。

JMM 是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。实现 Java 程序能够“一次编写，到处运行”。

### Java 的并发采用的就是共享内存模型

JMM 定义了线程和主内存之间的抽象关系


    线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。

本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化（各种高级语言，包括Java，的多线程内存模型中，在线程栈内自己维护一份缓存是常见的优化措施）。

__线程对变量的操作都是在工作内存中完成，操作结束后再放回主内存__。

JMM 决定一个线程对共享变量的写入何时对另一个线程可见。

通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，提供内存可见性保证。

#### 面临的问题

多线程通过共享内存进行通信时，存在__主内存和本地内存数据不一致、编译器对代码指令重排序、处理器对代码优化__等带来的问题，对应并发编程中的三个问题，可见性、有序性、原子性。

#### 产生的原因

指令重排序（提高性能）、数据依赖性（不改变存在数据依赖关系的操作）、as-if-serial（单线程下的执行结果不变）、内存屏障（volatile）、happens-before

两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。

#### 解决的方式

JMM 解决并发问题主要采用两种方式：__限制处理器优化和使用内存屏障__。

##### 限制处理器优化

##### 使用内存屏障

内存屏障，除了实现CPU之前的数据可见性之外，还有一个重要的职责，可以禁止指令的重排序。

这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后会更有效率，编译后，这个指令就在最后了（前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化），一旦编译器对某个变量的写操作进行优化（放到最后），那么在执行之前，另一个线程将不会看到这个执行结果。

当然了，写入动作可能被移到后面，那也有可能被挪到了前面，这样的“优化”有什么影响呢？这种情况下，其它线程可能会在程序实现“发生”之前，看到这个写入动作（这里怎么理解，指令已经执行了，但是在代码层面还没执行到）。通过内存屏障的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高的性能，同时保证程序的正确性。



硬件上的，被volatile修饰的变量在进行写操作时，会生成一个特殊的汇编指令，该指令会触发mesi协议，会存在一个总线嗅探机制的东西，简单来说就是这个cpu会不停检测总线中该变量的变化，如果该变量一旦变化了，由于这个嗅探机制，其它cpu会立马将该变量的cpu缓存数据清空掉，重新的去从主内存拿到这个数据。



#### MESI协议的缓存状态机

MESI协议解决了CPU缓存层面的可见性问题。

M（修改, Modified）: 本地处理器已经修改缓存行, 即是脏行, 它的内容与内存中的内容不一样. 并且此cache只有本地一个拷贝（专有）。

E（专有, Exclusive）: 缓存行内容和内存中的一样, 而且其它处理器都没有这行数据。

S（共享, Shared）: 缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝。

I（无效, Invalid）: 缓存行失效, 不能使用。

## Java 内存结构

Java 内存结构指的 Java 虚拟机的`运行时数据区（Run-Time Data Areas）`的结构。

### Java虚拟机栈（JVM Stack）

Java虚拟机栈，线程私有的，生命周期与线程相同。

会有两种异常`StackOverFlowError`和`OutOfMemoryError`。

- 当线程请求栈深度大于虚拟机所允许的深度就会抛出`StackOverFlowError`错误；
- 虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出`OutOfMemoryError`错误。

#### 栈帧（Stack Frame）

一个线程的每个方法在执行的同时，都会创建一个栈帧（Stack Frame）。

当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。

##### 局部变量表（Local Variables）

局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。

在局部变量表中，只有`long`和`double`类型会占用2个__局部变量空间__（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。

局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。

##### 操作栈（Operand Stacks）

##### 动态连接（Dynamic Linking）

##### 返回地址（Return Address）

##### 帧数据区（Stack Data）

### 堆区（Heap）

在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域

堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。

堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。

堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。

如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，会抛出异常OutOfMemoryError:Java heap space。

### 方法区（Method Area）

被所有线程共享区域，用于存放已被虚拟机加载的类信息，final常量，静态变量，编译器即时编译的代码等数据。

被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（PermGen，permanent generation）

（由于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。）

垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池内存回收，类型卸载。

常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern()方法。

在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。

方法区物理上存在于堆里，而且是在堆的持久代里面；但在逻辑上，方法区和堆是独立的。 一般说堆的持久代就是说方法区，因为一旦JVM把方法区（类信息，常量池，静态字段，方法）加载进内存以后，这些内存一般是不会被回收的了。

### 程序计数器（Program Counter Register）

用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。

通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。

为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。

程序计数器只是记录当前指令地址，因此是唯一一块Java虚拟机没有规定任何OutOfMemoryError的区块

### 直接内存（Direct Memory）

直接内存并不是JVM管理的内存，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，

JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。

由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。

### 本地方法栈（Native Method Stack）

本地方法栈的作用，运行机制，异常类型等方面都与虚拟机栈相同

虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，

在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。

本地方法栈也是线程私有的。

本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

native方法，被native关键字修饰的方法叫做本地方法，本地方法和其它方法不一样，本地方法意味着和平台有关，因此使用了native的程序可移植性都不太高。

另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的本地方法栈。

native方法主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。

被native修饰的方法可以被C语言重写。
```
1.Java程序中声明native修饰的方法，类似于abstract修饰的方法，只有方法签名，没有方法实现。编译该java文件，会产生一个.class文件。
2.使用javah编译上一步产生的class文件，会产生一个.h文件。
3.写一个.cpp文件实现上一步中.h文件中的方法。
4.将上一步的.cpp文件编译成动态链接库文件.dll。
5.最后就可以使用System或是Runtime中的loadLibrary()方法加载上一步的产生的动态连接库文件了。
```


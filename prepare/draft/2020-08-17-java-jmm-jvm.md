---
layout: post
title:  " Java 内存模型和 Java 内存结构"
subtitle: ""
tags: [Java, JMM, JVM]
comments: true
---
# Java 内存模型和 Java 内存结构
## 内存模型



#### CPU 读写

计算机的 CPU 数量可能会是2个或以上，而且每个 CPU 又会包含多个核心。因而，一个多线程应用的线程可能会分布在不同 CPU 的不同核心中并行运行。

当 CPU 需要访问主存（RAM）时，会先读取一部分主存数据到 CPU 缓存（CPU Cache，多级缓存，一般分为L1、L2、L3缓存），进而在读取 CPU缓存  中的数据到 寄存器（Register）。

当 CPU 需要写数据到主存时，同样会先 flush 寄存器 到 CPU缓存，然后再在某些节点把缓存数据 flush 到 主存。

因为这些缓存的存在，提供了数据的访问性能，也减轻了数据总线上数据传输的压力。

内存模型可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。

比如，两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。所以在CPU的层面，这种可见性，应该如何实现呢？

内存模型定义了一个充分必要条件，保证其它CPU的写入动作对该CPU是可见的，而且该CPU的写入动作对其它CPU也是可见的。

不同架构下的物理机拥有不一样的内存模型。

#### 硬件内存模型

##### 强内存模型

有些处理器提供了强内存模型，所有CPU在任何时候都能看到内存中任意位置相同的值，这种完全是硬件提供的支持。

##### 弱内存模型

其它处理器，提供了弱内存模型，需要执行一些特殊指令（memory barriers内存屏障），刷新CPU缓存的数据到内存中，保证这个写操作能够被其它CPU可见，或者将CPU缓存的数据设置为无效状态，保证其它CPU的写操作对本CPU可见。通常这些内存屏障的行为由底层实现，对于上层语言的程序员来说是透明的（不需要太关心具体的内存屏障如何实现）。


### Java内存模型
Java 内存模型（JMM，Java Memory Model）本身是一种抽象的概念。

指的是 JDK 5 开始使用的新的内存模型，主要由` JSR-133: JavaTM Memory Model and Thread Specification`描述。

是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

#### 并发编程

在并发编程中，要处理的两个关键问题就是这两条标准的体现：线程之间如何通信以及线程之间如何同步。

##### 通信

通信是指线程之间以何种机制来交换信息。在命令式的编程中，线程之间的通信机制有两种：共享内存和消息传递。

在__共享内存__并发的模型里，线程之间共享程序的公共状态，线程之间通过读/写内存中的公共状态来隐式进行通信。典型的共享内存通信方式就是通过共享对象进行通信。

在__消息传递__的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显示进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。

##### 同步

同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在__共享内存__并发模型里，同步是显示进行的，开发人员必须显示指定某个方法或某段代码需要在线程之间互斥进行。

在__消息传递__的并发模型里，由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。

##### Java的并发采用的就是共享内存模型。

JMM 主要解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码优化等带来的问题。

JMM 决定一个线程对共享变量的写入何时对另一个线程可见。

JMM 解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。

JMM 定义了线程和主内存之间的抽象关系


    线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。


__本地内存是 JMM 的一个抽象概念，并不真实存在。__

它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

## Java 内存结构

Java 内存结构指的 Java 虚拟机的`运行时数据区（Run-Time Data Areas）`的结构。

### Java虚拟机栈（JVM Stack）

Java虚拟机栈，线程私有的，生命周期与线程相同。

会有两种异常`StackOverFlowError`和`OutOfMemoryError`。

- 当线程请求栈深度大于虚拟机所允许的深度就会抛出`StackOverFlowError`错误；
- 虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出`OutOfMemoryError`错误。

#### 栈帧（Stack Frame）

一个线程的每个方法在执行的同时，都会创建一个栈帧（Stack Frame）。

当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。

##### 局部变量表（Local Variables）

局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。

在局部变量表中，只有`long`和`double`类型会占用2个__局部变量空间__（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。

局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。

##### 操作栈（Operand Stacks）

##### 动态连接（Dynamic Linking）

##### 返回地址（Return Address）

##### 帧数据区（Stack Data）

#### 堆区（Heap）

在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域

堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。

堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。

堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。

如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，会抛出异常OutOfMemoryError:Java heap space。

#### 方法区（Method Area）

被所有线程共享区域，用于存放已被虚拟机加载的类信息，final常量，静态变量，编译器即时编译的代码等数据。

被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（PermGen，permanent generation）

（由于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。）

垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池内存回收，类型卸载。

常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern()方法。

在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。

#### 程序计数器（Program Counter Register）

用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。

通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。

为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。

程序计数器只是记录当前指令地址，因此是唯一一块Java虚拟机没有规定任何OutOfMemoryError的区块

#### 直接内存（Direct Memory）

直接内存并不是JVM管理的内存，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，

JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。

由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。
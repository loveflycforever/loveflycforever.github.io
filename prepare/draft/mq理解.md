要实现严格的顺序消息，简单且可行的办法就是：
保证生产者 - MQServer - 消费者是一对一对一的关系
        并行度就会成为消息系统的瓶颈（吞吐量不够）
        更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。

造成消息重复的根本原因是：网络不可达。
只要通过网络交换数据，就无法避免这个问题。
所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？
        消费端处理消息的业务逻辑保持幂等性
        保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
第1条解决方案，在消费端实现，不属于消息系统要实现的功能。
第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题。
RocketMQ不保证消息不重复，如果业务需要保证严格的不重复消息，需要在业务端去重。


事务消息
大事务 = 小事务 + 异步
比如转账，分为 减钱+发消息+加钱 的过程，将发消息和减钱放入一个事务，发消息失败就回滚。
RocketMQ支持事务消息，实现方式为，第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。
如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

解决消费端超时问题，就是一直重试，直到消费端消费消息成功。
解决消费端失败问题，阿里提供的解决方法是：人工解决。因为需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题。

在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以tryToFindTopicPublishInfo会首先从缓存中获取topic路由信息，如果没有获取到，则会自己去namesrv获取路由信息。selectOneMessageQueue方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。

如果Producer发送消息失败，会自动重试，重试的策略：
	

重试次数 < retryTimesWhenSendFailed（可配置）

	总的耗时（包含重试n次的耗时） < sendMsgTimeout（发送消息时传入的参数）

同时满足上面两个条件后，Producer会选择另外一个队列发送消息

。

RocketMQ的消息存储是由consume queue和commit log配合完成的。
consume queue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。每个topic下的每个queue都有一个对应的consumequeue文件。
按照消费端的GroupName来分组重试队列，如果消费端消费失败，消息将被发往重试队列中。

按照消费端的GroupName来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列。



死信队列（Dead Letter Queue）一般用于存放由于某种原因无法传递的消息，比如处理失败或者已经过期的消息。

Consume Queue中存储单元是一个20字节定长的二进制数据，顺序写顺序读，三部分组成，CommitLog Offset（8byte）、Size（4byte）、Message Tag HashCode（8byte）。
    CommitLog Offset是指这条消息在Commit Log文件中的实际偏移量
    Size存储中消息的大小
    Message Tag HashCode存储消息的Tag的哈希值：主要用于订阅时消息过滤（订阅时如果指定了Tag，会根据HashCode来快速查找到订阅的消息）

CommitLog：消息存放的物理文件，每台broker上的commitlog被本机所有的queue共享，不做任何区分。
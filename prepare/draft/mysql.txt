异步处理
应用解耦
流量削锋 秒杀
日志处理
消息通讯

mysql mha (vip zookeeper) memeryCached (cluster、Galera、POAXS) master slave
MySQL + 分布式Proxy 水平扩展架构 MyCAT
TokuDB/MyRocks/InnoDB 高性能写入架构
MySQL + 缓存（Memcached、Redis等） 高并发读架构
MySQL + 小文件系统（MongoDB、Ceph等） 大字段存取架构
MySQL + Inforbright/Greenplum 统计分析架构  线上OLTP和线下OLAP的结合使用和执行。

    MySQL+MHA高可用架构 与 MySQL分布式Proxy水平扩展架构 组合
    MySQL+MHA高可用架构 与 MySQL小文件系统大字段存取架构 组合
    MySQL+MHA高可用架构 与 MySQL缓存高并发读架构 组合
    MySQL分布式Proxy水平扩展架构 与 MySQL小文件系统大字段存取架构 组合
    MySQL分布式Proxy水平扩展架构 与 MySQL缓存高并发读架构 组合
    MySQL高性能写入架构  与 MySQL Inforbright/Greenplum统计分析架构 组合

业务系统通常会有DAU、UV、PV等指标，来帮助判断业务系统的规模。数据库系统、QPS、TPS、一个表的数据量、一个库下的表数量、一个实例下的库数量、总的实例数量、服务器数量，都是与架构结合比较紧密的指标。
以表数据量举例：如果一个表运行一年，数量在10万以下，就可以认为是小表了数据量在10万-1000万以上的，可以认为是中表；数据量在1000万以上，就可以认为是大表

MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。

MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。

最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。

MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。

客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。

MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。




    用多个小表代替一个大表，注意不要过度设计
    批量插入代替循环单条插入
    合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适
    可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存

最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。

MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。

MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。

过程：
客户端向MySQL服务器发送一条查询请求
服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
MySQL根据执行计划，调用存储引擎的API来执行查询
将结果返回给客户端，同时缓存查询结果

resultset不能嵌套查询
一个Statement对象同时只能有一个结果集在活动.这是宽容性的,就是说即使没有
调用ResultSet的close()方法,只要打开第二个结果集就隐含着对上一个结果集的关闭.所以
如果你想同时对多个结果集操作,就要创建多个Statement对象,如果不需要同时操作,那么可
以在一个Statement对象上顺序操作多个结果集.

好在一个connection
对象可以创建任意多个Statement对象,而不需要你重新获取连结.


mysql不能存储中文的原因
首先将mysql.ini配置文件的UTF8的setting注释解开
第二将client和mysqld的default-character-set（不知道是不是这样写，忘了）设置为utf8
第三创建数据库数据表的时候将编码设置为utf8和utf8_unicion_ci


技巧：

    通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。
    对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。
    UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。
    通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。
    TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。
    大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。
    schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。
    大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。


join执行过程
第一步：执行FROM子句对两张表进行笛卡尔积操作
第二步：执行ON子句过滤掉不满足条件的行
第三步：JOIN 添加外部行
第四步：WHERE条件过滤
第五步：SELECT


InnoDB逻辑存储结构，所有数据都被逻辑地存放在表空间，表空间又由段，区，页组成。
段
段就是上图的segment区域，常见的段有数据段、索引段、回滚段等，在InnoDB存储引擎中，对段的管理都是由引擎自身所完成的。

区
区就是上图的extent区域，区是由连续的页组成的空间，无论页的大小怎么变，区的大小默认总是为1MB。

为了保证区中的页的连续性，InnoDB存储引擎一次从磁盘申请4-5个区，InnoDB页的大小默认为16kb，即一个区一共有64（1MB/16kb=16）个连续的页。

每个段开始，先用32页（page）大小的碎片页来存放数据，在使用完这些页之后才是64个连续页的申请。这样做的目的是，对于一些小表或者是undo类的段，可以开始申请较小的空间，节约磁盘开销。

页
页就是上图的page区域，也可以叫块。页是InnoDB磁盘管理的最小单位。默认大小为16KB，可以通过参数innodb_page_size来设置。

常见的页类型有：数据页，undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页，未压缩的二进制大对象页，压缩的二进制大对象页等。

----

一行数据的最大长度就限制为了8k。

innodb的页块大小默认为16kb，表中数据是存放在B-tree node的页块中，但如果表中一行的数据长度超过了16k，这时候就会出现行溢出，溢出的行是存放在另外的地方，存放该溢出数据的页叫uncompresse blob page。

innodb采用聚簇索引的方式把数据存放起来，即B+树结构，因此每个页块中至少有两行数据，否则就失去了B+树的意义（每一个页中只有一条数据，整个树成为了一条双向链表），这样就得出了一行数据的最大长度就限制为了8k。

当插入的一行数据不能在一个数据页块中存放时，为了保证该页至少能存放两行数据，innodb将会自动部分数据溢出到另外页中，一部分数据将存放在数据页块中，其大小为该列的前768字节，同时接着还有偏移指向溢出页。

如果有10个大字段（如varchar（1000），text，blob同varchar同样存储前768字节），同样会超过一行数据8k的限制（10x768<8000,11x768>8000）。如果插入的值超过8000字节，则会报错（BLOB或TEXT同理）

解决方法:

减少varchar（1000）的字段数量，或者改存储引擎为myisam；
还可以增加page_size的大小：如改为32k，64k。由于需求不好改动，数据库的页块大小改变需要改动源码，
该表以若查询为主，更新非常少，可以改为myisam存储引擎。myisam存储引擎不受此限制。


在innodb plugin的版本中，mysql引入了新的文件格式：barracuda，梭鱼；
该文件格式中拥有两种新的行记录:compressed，dynamic，这两钟格式对于BLOB数据完全采用行溢出方式，在数据页中只占用20字节用于指向溢出页。

Antelope是innodb-base的文件格式，Barracude是innodb-plugin后引入的文件格式，同时Barracude也支持Antelope文件格式。两者区别在于：

Antelope（Innodb-base）

支持行格式ROW_FORMAT=COMPACT，ROW_FORMAT=REDUNDANT特性 Compact和Redumdant的区别在就是在于首部的存存内容区别。compact的存储格式为首部为一个非NULL的变长字段长度列表,redundant的存储格式为首部是一个字段长度偏移列表（每个字段占用的字节长度及其相应的位移）。在Antelope中对于变长字段，低于768字节的，不会进行overflow page存储，某些情况下会减少结果集IO.

Barracuda(innodb-plugin)

支持行格式ROW_FORMAT=DYNAMIC，ROW_FORMAT=COMPRESSED特性 这两者主要是功能上的区别功能上的。另外在行里的变长字段和Antelope的区别是只存20个字节，其它的overflow page存储。另外这两都需要开启innodb\_file\_per\_table=1（这个特性对一些优化还是很有用的）


mysql中若一张表里面存在varchar、text以及其变形、blob以及其变形的字段的话，那么这个表其实也叫动态表，即该表的 row_format是dynamic，就是说每条记录所占用的字节是动态的。其优点节省空间，缺点增加读取的时间开销。反之，这张表叫静态表，该表 row_format为fixed,即每条记录占用字节一样。优点读取快，缺点浪费部分空间，所以，做搜索查询量大的表一般都以空间来换取时间，设计成静态表。

修改行格式

ALTER TABLE table_name ROW_FORMAT = DEFAULT

修改过程导致：

fixed--->dynamic: 这会导致CHAR变成VARCHAR

dynamic--->fixed: 这会导致VARCHAR变成CHAR

需要注意，如果要使用压缩，一定需要先使用innodb_file_format =Barracuda格式，不然没作用。
-------

索引的分类
从存储结构上来划分
Btree索引（B+tree，B-tree)
哈希索引
full-index全文索引
RTree

普通索引、复合索引：即一个索引只包含单个列，一个表可以有多个单列索引。
唯一索引：索引列的值必须唯一，但允许有空值。

聚集索引：表记录的排列顺序和索引的排列顺序一致。
聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。
缺点：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。
聚集索引在叶子节点存储的是表中的数据。

非聚集索引：表记录的排列顺序和索引的排列顺序不一致。
索引的逻辑顺序与磁盘上行的物理存储顺序不同，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是我们所说的回表。
非聚集索引在叶子节点存储的是主键和索引列。



MyISAM的索引文件（.MYI）和数据文件（.MYD）文件是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些指针来读取页，进而读取被索引的行。
树中的叶子节点保存的是对应行的物理位置。通过该值，==存储引擎能顺利地进行回表查询，得到一行完整记录==。
同时，每个叶子也保存了指向下一个叶子的指针，从而方便叶子节点的范围遍历。
在MyISAM中，主键索引和辅助索引在结构上没有任何区别，==只是主键索引要求key是唯一的，而辅助索引的key可以重复==。

---

违反最左匹配原则
如果建立的索引是(a,b,c)，也只有(a),(a,b),(a,b,c)三种查询可以生效。
当使用abc会完全使用联合索引的abc三列，使用ab只会使用联合索引中的两列，使用a或者ac只会使用联合索引中的a列（可以通过explain的key_len看出，是指索引类型的字节长度），至于其他情况联合索引不会被使用。
sql语句中字段的顺序不需要和联合索引中定义的字段顺序一致，查询优化器会自己调整顺序

在索引列上做计算、函数、（手动或自动）类型转换等操作，使用不等于（!= 、<>），like中以通配符开头('%abc')


字符串不加单引号索引失效


or连接索引失效


order by违反最左前缀法则，导致额外的文件排序（会降低性能）。例如索引为 col, pos, 只order by pos;

group by违反最左前缀法则，导致产生临时表（会降低性能）。
-----

分区的意思是指将同一表中不同行的记录分配到不同的物理文件中，几个分区就有几个.idb文件，不是我们刚刚说的区。MySQL在5.1时添加了对水平分区的支持。
分区是将一个表或索引分解成多个更小，更可管理的部分。

每个区都是独立的，可以独立处理，也可以作为一个更大对象的一部分进行处理。这个是MySQL支持的功能，业务代码无需改动。要知道MySQL是面向OLTP的数据，它不像TIDB等其他DB。
MySQL数据库的分区是局部分区索引，一个分区中既存了数据，又放了索引。也就是说，每个区的聚集索引和非聚集索引都放在各自区的（不同的物理文件）。目前MySQL数据库还不支持全局分区。

目前MySQL支持一下几种类型的分区，RANGE分区，LIST分区，HASH分区，KEY分区。

无论哪种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。




项目中需要解决幻读的话也有两个办法：

使用串行化读的隔离级别
MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)

实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。
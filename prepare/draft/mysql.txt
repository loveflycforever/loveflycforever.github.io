异步处理
应用解耦
流量削锋 秒杀
日志处理
消息通讯

mysql mha (vip zookeeper) memeryCached (cluster、Galera、POAXS) master slave
MySQL + 分布式Proxy 水平扩展架构 MyCAT
TokuDB/MyRocks/InnoDB 高性能写入架构
MySQL + 缓存（Memcached、Redis等） 高并发读架构
MySQL + 小文件系统（MongoDB、Ceph等） 大字段存取架构
MySQL + Inforbright/Greenplum 统计分析架构  线上OLTP和线下OLAP的结合使用和执行。

    MySQL+MHA高可用架构 与 MySQL分布式Proxy水平扩展架构 组合
    MySQL+MHA高可用架构 与 MySQL小文件系统大字段存取架构 组合
    MySQL+MHA高可用架构 与 MySQL缓存高并发读架构 组合
    MySQL分布式Proxy水平扩展架构 与 MySQL小文件系统大字段存取架构 组合
    MySQL分布式Proxy水平扩展架构 与 MySQL缓存高并发读架构 组合
    MySQL高性能写入架构  与 MySQL Inforbright/Greenplum统计分析架构 组合

业务系统通常会有DAU、UV、PV等指标，来帮助判断业务系统的规模。数据库系统、QPS、TPS、一个表的数据量、一个库下的表数量、一个实例下的库数量、总的实例数量、服务器数量，都是与架构结合比较紧密的指标。
以表数据量举例：如果一个表运行一年，数量在10万以下，就可以认为是小表了数据量在10万-1000万以上的，可以认为是中表；数据量在1000万以上，就可以认为是大表

MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。

MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。

最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。

作者：CHEN川
链接：https://www.jianshu.com/p/d7665192aaaf
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。

客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。

MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。




    用多个小表代替一个大表，注意不要过度设计
    批量插入代替循环单条插入
    合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适
    可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存

最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。

MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。

MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。

过程：
客户端向MySQL服务器发送一条查询请求
服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
MySQL根据执行计划，调用存储引擎的API来执行查询
将结果返回给客户端，同时缓存查询结果

作者：CHEN川
链接：https://www.jianshu.com/p/d7665192aaaf
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


技巧：

    通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。
    对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。
    UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。
    通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。
    TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。
    大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。
    schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。
    大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。

作者：CHEN川
链接：https://www.jianshu.com/p/d7665192aaaf
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
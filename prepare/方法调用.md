**方法调用**

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。

```
静态链接
```

当一个字节码文件被装载进JVM内部时，如果被调用的`目标方法在编译期可知`，且运行期间保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。

```
动态链接
```

如果`被调用方法在编译期间无法被确定下来`，只能在程序运行时将调用方法的符号引用转换为直接引用，由于这种引用转换的过程具备动态性，因此也就被称为动态链接。

对应的绑定机制为：早期绑定（Early Binding）、晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用，这个过程仅发生一次。

```
早期绑定
```

早期绑定就是指被调用的`目标方法如果在编译期可知，且运行期保持不变`时，即可将这个方法所属的类型进行绑定，这样一来，由于明确了被调用方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用替换为直接引用。

```
晚期绑定
```

如果`被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关方法`这种绑定就叫做晚期绑定。

**方法的调用：虚方法与非虚方法**

如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称之为非虚方法。

静态变量、私有方法、final方法、实例构造器、父类方法都是非虚方法。

其它方法称之为虚方法、


普通调用指令：

1. **invokestatic** ： 静态方法，解析阶段确定唯一方法版本
2. **invokespecial** ： 调用``方法、私有方法以及父类方法，解析阶段确定唯一方法版本
3. invokevirtual ： 调用所有虚方法
4. invokeinterface ： 调用接口方法

动态调用指令：

invokedynamic ： 动态解析所需要调用的方法，然后执行

前四条指令固化在虚拟机的内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定版本。其中invokevirtual和invokestatic指令调用的方法称为非虚方法，其余的（final修饰除外）称为虚方法。

invokedynamic指令是在JDK7中增加的，为了实现动态类型语言支持而做的一种改进。

但是在JDK7中并没有提供直接生成的invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到JDK8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接生成的方式。


方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。


运行时常量池
运行时常量池（ Runtime Constant Pool）是方法区的一部分。
常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。

运行时常量池类似于传统编程语言中的符号表（symbol table） ，但是它所包含的数据却比符号表要更加丰富一些。
当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。
方法区的演进细节
首先明确：只有HotSpot才有永久代。 BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虛拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。

Hotspot中 方法区的变化：

jdk1.6及之前：有永久代（permanent generation） ，静态变量存放在 永久代上。
jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中。
jdk1.8及之后： 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍留在堆空间。

永久代为什么要被元空间替换

随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类.的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（ Metaspace ）。
由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
这项改动是很有必要的，原因有：

为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生Perm区（永久代）的O0M。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 "Exception in thread' dubbo client x.x connector’java.lang.OutOfMemoryError：PermGenspace" 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
对永久代进行调优是很困难的。
StringTable为什么要调整

jdk7中将StringTable放到了堆空间中，正确。
因为永久代的回收频率很低，在Full GC的时候才会触发。而Full GC是老年代的空间不足、永久代不足时才会触发。这就导致了StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存.
方法区的垃圾回收


方法区的垃圾收集主要回收两部分内容：常量池中废奔的常量和不再使用的类型。

常量池中废奔的常量

先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念。
常量池中包括下面三类常量：

类和接口的全限定名
字段的名称和描述符
方法的名称和描述符
HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。
常量池中不再使用的类型

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了一Xnoclassgc 参数进行控制，还可以使用一verbose：class以及一XX： +TraceClass一Loading、一XX：+TraceClassUnLoading查 看类加载和卸载信息。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。


堆设置
-Xms:初始堆大小
-Xmx:最大堆大小
-Xmn:新生代大小
-XX:NewRatio:设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3
-XX:SurvivorRatio:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5  
-XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代
-XX:PermSize、-XX:MaxPermSize:分别设置永久代最小大小与最大大小（Java8以前）
-XX:MetaspaceSize、-XX:MaxMetaspaceSize:分别设置元空间最小大小与最大大小（Java8以后）
收集器设置
-XX:+UseSerialGC:设置串行收集器
-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行老年代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器
垃圾回收统计信息
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:filename
并行收集器设置
-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
并发收集器设置
-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
-XX:ParallelGCThreads=n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。